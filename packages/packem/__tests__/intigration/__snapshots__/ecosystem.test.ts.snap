// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`packem ecosystem > should work with provided 'sitefetch' ecosystem suite 1`] = `
[
  "export {};
",
  "#!/usr/bin/env node
import path from 'node:path';
import fs from 'node:fs';
import { EventEmitter } from 'events';
import { encode } from 'gpt-tokenizer/model/gpt-4o';
import { l as logger, f as fetchSite, a as formatNumber, s as serializePages, e as ensureArray } from './packem_shared/index-DjmSPXQS.mjs';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function toArr(any) {
  return any == null ? [] : Array.isArray(any) ? any : [any];
}
__name(toArr, "toArr");
function toVal(out, key, val, opts) {
  var x, old = out[key], nxt = !!~opts.string.indexOf(key) ? val == null || val === true ? "" : String(val) : typeof val === "boolean" ? val : !!~opts.boolean.indexOf(key) ? val === "false" ? false : val === "true" || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;
  out[key] = old == null ? nxt : Array.isArray(old) ? old.concat(nxt) : [old, nxt];
}
__name(toVal, "toVal");
function mri2(args, opts) {
  args = args || [];
  opts = opts || {};
  var k, arr, arg, name, val, out = { _: [] };
  var i = 0, j = 0, idx = 0, len = args.length;
  const alibi = opts.alias !== undefined;
  const strict = opts.unknown !== undefined;
  const defaults = opts.default !== undefined;
  opts.alias = opts.alias || {};
  opts.string = toArr(opts.string);
  opts.boolean = toArr(opts.boolean);
  if (alibi) {
    for (k in opts.alias) {
      arr = opts.alias[k] = toArr(opts.alias[k]);
      for (i = 0; i < arr.length; i++) {
        (opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
      }
    }
  }
  for (i = opts.boolean.length; i-- > 0; ) {
    arr = opts.alias[opts.boolean[i]] || [];
    for (j = arr.length; j-- > 0; ) opts.boolean.push(arr[j]);
  }
  for (i = opts.string.length; i-- > 0; ) {
    arr = opts.alias[opts.string[i]] || [];
    for (j = arr.length; j-- > 0; ) opts.string.push(arr[j]);
  }
  if (defaults) {
    for (k in opts.default) {
      name = typeof opts.default[k];
      arr = opts.alias[k] = opts.alias[k] || [];
      if (opts[name] !== undefined) {
        opts[name].push(k);
        for (i = 0; i < arr.length; i++) {
          opts[name].push(arr[i]);
        }
      }
    }
  }
  const keys = strict ? Object.keys(opts.alias) : [];
  for (i = 0; i < len; i++) {
    arg = args[i];
    if (arg === "--") {
      out._ = out._.concat(args.slice(++i));
      break;
    }
    for (j = 0; j < arg.length; j++) {
      if (arg.charCodeAt(j) !== 45) break;
    }
    if (j === 0) {
      out._.push(arg);
    } else if (arg.substring(j, j + 3) === "no-") {
      name = arg.substring(j + 3);
      if (strict && !~keys.indexOf(name)) {
        return opts.unknown(arg);
      }
      out[name] = false;
    } else {
      for (idx = j + 1; idx < arg.length; idx++) {
        if (arg.charCodeAt(idx) === 61) break;
      }
      name = arg.substring(j, idx);
      val = arg.substring(++idx) || (i + 1 === len || ("" + args[i + 1]).charCodeAt(0) === 45 || args[++i]);
      arr = j === 2 ? [name] : name;
      for (idx = 0; idx < arr.length; idx++) {
        name = arr[idx];
        if (strict && !~keys.indexOf(name)) return opts.unknown("-".repeat(j) + name);
        toVal(out, name, idx + 1 < arr.length || val, opts);
      }
    }
  }
  if (defaults) {
    for (k in opts.default) {
      if (out[k] === undefined) {
        out[k] = opts.default[k];
      }
    }
  }
  if (alibi) {
    for (k in out) {
      arr = opts.alias[k] || [];
      while (arr.length > 0) {
        out[arr.shift()] = out[k];
      }
    }
  }
  return out;
}
__name(mri2, "mri2");
const removeBrackets = /* @__PURE__ */ __name((v) => v.replace(/[<[].+/, "").trim(), "removeBrackets");
const findAllBrackets = /* @__PURE__ */ __name((v) => {
  const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
  const SQUARE_BRACKET_RE_GLOBAL = /\\[([^\\]]+)\\]/g;
  const res = [];
  const parse = /* @__PURE__ */ __name((match) => {
    let variadic = false;
    let value = match[1];
    if (value.startsWith("...")) {
      value = value.slice(3);
      variadic = true;
    }
    return {
      required: match[0].startsWith("<"),
      value,
      variadic
    };
  }, "parse");
  let angledMatch;
  while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(angledMatch));
  }
  let squareMatch;
  while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(squareMatch));
  }
  return res;
}, "findAllBrackets");
const getMriOptions = /* @__PURE__ */ __name((options) => {
  const result = { alias: {}, boolean: [] };
  for (const [index, option] of options.entries()) {
    if (option.names.length > 1) {
      result.alias[option.names[0]] = option.names.slice(1);
    }
    if (option.isBoolean) {
      if (option.negated) {
        const hasStringTypeOption = options.some((o, i) => {
          return i !== index && o.names.some((name) => option.names.includes(name)) && typeof o.required === "boolean";
        });
        if (!hasStringTypeOption) {
          result.boolean.push(option.names[0]);
        }
      } else {
        result.boolean.push(option.names[0]);
      }
    }
  }
  return result;
}, "getMriOptions");
const findLongest = /* @__PURE__ */ __name((arr) => {
  return arr.sort((a, b) => {
    return a.length > b.length ? -1 : 1;
  })[0];
}, "findLongest");
const padRight = /* @__PURE__ */ __name((str, length) => {
  return str.length >= length ? str : \`\${str}\${" ".repeat(length - str.length)}\`;
}, "padRight");
const camelcase = /* @__PURE__ */ __name((input) => {
  return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
    return p1 + p2.toUpperCase();
  });
}, "camelcase");
const setDotProp = /* @__PURE__ */ __name((obj, keys, val) => {
  let i = 0;
  let length = keys.length;
  let t = obj;
  let x;
  for (; i < length; ++i) {
    x = t[keys[i]];
    t = t[keys[i]] = i === length - 1 ? val : x != null ? x : !!~keys[i + 1].indexOf(".") || !(+keys[i + 1] > -1) ? {} : [];
  }
}, "setDotProp");
const setByType = /* @__PURE__ */ __name((obj, transforms) => {
  for (const key of Object.keys(transforms)) {
    const transform = transforms[key];
    if (transform.shouldTransform) {
      obj[key] = Array.prototype.concat.call([], obj[key]);
      if (typeof transform.transformFunction === "function") {
        obj[key] = obj[key].map(transform.transformFunction);
      }
    }
  }
}, "setByType");
const getFileName = /* @__PURE__ */ __name((input) => {
  const m = /([^\\\\\\/]+)$/.exec(input);
  return m ? m[1] : "";
}, "getFileName");
const camelcaseOptionName = /* @__PURE__ */ __name((name) => {
  return name.split(".").map((v, i) => {
    return i === 0 ? camelcase(v) : v;
  }).join(".");
}, "camelcaseOptionName");
class CACError extends Error {
  static {
    __name(this, "CACError");
  }
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
}
class Option {
  static {
    __name(this, "Option");
  }
  constructor(rawName, description, config) {
    this.rawName = rawName;
    this.description = description;
    this.config = Object.assign({}, config);
    rawName = rawName.replace(/\\.\\*/g, "");
    this.negated = false;
    this.names = removeBrackets(rawName).split(",").map((v) => {
      let name = v.trim().replace(/^-{1,2}/, "");
      if (name.startsWith("no-")) {
        this.negated = true;
        name = name.replace(/^no-/, "");
      }
      return camelcaseOptionName(name);
    }).sort((a, b) => a.length > b.length ? 1 : -1);
    this.name = this.names[this.names.length - 1];
    if (this.negated && this.config.default == null) {
      this.config.default = true;
    }
    if (rawName.includes("<")) {
      this.required = true;
    } else if (rawName.includes("[")) {
      this.required = false;
    } else {
      this.isBoolean = true;
    }
  }
}
const processArgs = process.argv;
const platformInfo = \`\${process.platform}-\${process.arch} node-\${process.version}\`;
class Command {
  static {
    __name(this, "Command");
  }
  constructor(rawName, description, config = {}, cli) {
    this.rawName = rawName;
    this.description = description;
    this.config = config;
    this.cli = cli;
    this.options = [];
    this.aliasNames = [];
    this.name = removeBrackets(rawName);
    this.args = findAllBrackets(rawName);
    this.examples = [];
  }
  usage(text) {
    this.usageText = text;
    return this;
  }
  allowUnknownOptions() {
    this.config.allowUnknownOptions = true;
    return this;
  }
  ignoreOptionDefaultValue() {
    this.config.ignoreOptionDefaultValue = true;
    return this;
  }
  version(version, customFlags = "-v, --version") {
    this.versionNumber = version;
    this.option(customFlags, "Display version number");
    return this;
  }
  example(example) {
    this.examples.push(example);
    return this;
  }
  option(rawName, description, config) {
    const option = new Option(rawName, description, config);
    this.options.push(option);
    return this;
  }
  alias(name) {
    this.aliasNames.push(name);
    return this;
  }
  action(callback) {
    this.commandAction = callback;
    return this;
  }
  isMatched(name) {
    return this.name === name || this.aliasNames.includes(name);
  }
  get isDefaultCommand() {
    return this.name === "" || this.aliasNames.includes("!");
  }
  get isGlobalCommand() {
    return this instanceof GlobalCommand;
  }
  hasOption(name) {
    name = name.split(".")[0];
    return this.options.find((option) => {
      return option.names.includes(name);
    });
  }
  outputHelp() {
    const { name, commands } = this.cli;
    const {
      versionNumber,
      options: globalOptions,
      helpCallback
    } = this.cli.globalCommand;
    let sections = [
      {
        body: \`\${name}\${versionNumber ? \`/\${versionNumber}\` : ""}\`
      }
    ];
    sections.push({
      title: "Usage",
      body: \`  $ \${name} \${this.usageText || this.rawName}\`
    });
    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
    if (showCommands) {
      const longestCommandName = findLongest(commands.map((command) => command.rawName));
      sections.push({
        title: "Commands",
        body: commands.map((command) => {
          return \`  \${padRight(command.rawName, longestCommandName.length)}  \${command.description}\`;
        }).join("\\n")
      });
      sections.push({
        title: \`For more info, run any command with the \\\`--help\\\` flag\`,
        body: commands.map((command) => \`  $ \${name}\${command.name === "" ? "" : \` \${command.name}\`} --help\`).join("\\n")
      });
    }
    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...globalOptions || []];
    if (!this.isGlobalCommand && !this.isDefaultCommand) {
      options = options.filter((option) => option.name !== "version");
    }
    if (options.length > 0) {
      const longestOptionName = findLongest(options.map((option) => option.rawName));
      sections.push({
        title: "Options",
        body: options.map((option) => {
          return \`  \${padRight(option.rawName, longestOptionName.length)}  \${option.description} \${option.config.default === undefined ? "" : \`(default: \${option.config.default})\`}\`;
        }).join("\\n")
      });
    }
    if (this.examples.length > 0) {
      sections.push({
        title: "Examples",
        body: this.examples.map((example) => {
          if (typeof example === "function") {
            return example(name);
          }
          return example;
        }).join("\\n")
      });
    }
    if (helpCallback) {
      sections = helpCallback(sections) || sections;
    }
    console.log(sections.map((section) => {
      return section.title ? \`\${section.title}:
\${section.body}\` : section.body;
    }).join("\\n\\n"));
  }
  outputVersion() {
    const { name } = this.cli;
    const { versionNumber } = this.cli.globalCommand;
    if (versionNumber) {
      console.log(\`\${name}/\${versionNumber} \${platformInfo}\`);
    }
  }
  checkRequiredArgs() {
    const minimalArgsCount = this.args.filter((arg) => arg.required).length;
    if (this.cli.args.length < minimalArgsCount) {
      throw new CACError(\`missing required args for command \\\`\${this.rawName}\\\`\`);
    }
  }
  checkUnknownOptions() {
    const { options, globalCommand } = this.cli;
    if (!this.config.allowUnknownOptions) {
      for (const name of Object.keys(options)) {
        if (name !== "--" && !this.hasOption(name) && !globalCommand.hasOption(name)) {
          throw new CACError(\`Unknown option \\\`\${name.length > 1 ? \`--\${name}\` : \`-\${name}\`}\\\`\`);
        }
      }
    }
  }
  checkOptionValue() {
    const { options: parsedOptions, globalCommand } = this.cli;
    const options = [...globalCommand.options, ...this.options];
    for (const option of options) {
      const value = parsedOptions[option.name.split(".")[0]];
      if (option.required) {
        const hasNegated = options.some((o) => o.negated && o.names.includes(option.name));
        if (value === true || value === false && !hasNegated) {
          throw new CACError(\`option \\\`\${option.rawName}\\\` value is missing\`);
        }
      }
    }
  }
}
class GlobalCommand extends Command {
  static {
    __name(this, "GlobalCommand");
  }
  constructor(cli) {
    super("@@global@@", "", {}, cli);
  }
}
var __assign = Object.assign;
class CAC extends EventEmitter {
  static {
    __name(this, "CAC");
  }
  constructor(name = "") {
    super();
    this.name = name;
    this.commands = [];
    this.rawArgs = [];
    this.args = [];
    this.options = {};
    this.globalCommand = new GlobalCommand(this);
    this.globalCommand.usage("<command> [options]");
  }
  usage(text) {
    this.globalCommand.usage(text);
    return this;
  }
  command(rawName, description, config) {
    const command = new Command(rawName, description || "", config, this);
    command.globalCommand = this.globalCommand;
    this.commands.push(command);
    return command;
  }
  option(rawName, description, config) {
    this.globalCommand.option(rawName, description, config);
    return this;
  }
  help(callback) {
    this.globalCommand.option("-h, --help", "Display this message");
    this.globalCommand.helpCallback = callback;
    this.showHelpOnExit = true;
    return this;
  }
  version(version, customFlags = "-v, --version") {
    this.globalCommand.version(version, customFlags);
    this.showVersionOnExit = true;
    return this;
  }
  example(example) {
    this.globalCommand.example(example);
    return this;
  }
  outputHelp() {
    if (this.matchedCommand) {
      this.matchedCommand.outputHelp();
    } else {
      this.globalCommand.outputHelp();
    }
  }
  outputVersion() {
    this.globalCommand.outputVersion();
  }
  setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
    this.args = args;
    this.options = options;
    if (matchedCommand) {
      this.matchedCommand = matchedCommand;
    }
    if (matchedCommandName) {
      this.matchedCommandName = matchedCommandName;
    }
    return this;
  }
  unsetMatchedCommand() {
    this.matchedCommand = undefined;
    this.matchedCommandName = undefined;
  }
  parse(argv = processArgs, {
    run = true
  } = {}) {
    this.rawArgs = argv;
    if (!this.name) {
      this.name = argv[1] ? getFileName(argv[1]) : "cli";
    }
    let shouldParse = true;
    for (const command of this.commands) {
      const parsed = this.mri(argv.slice(2), command);
      const commandName = parsed.args[0];
      if (command.isMatched(commandName)) {
        shouldParse = false;
        const parsedInfo = __assign(__assign({}, parsed), {
          args: parsed.args.slice(1)
        });
        this.setParsedInfo(parsedInfo, command, commandName);
        this.emit(\`command:\${commandName}\`, command);
      }
    }
    if (shouldParse) {
      for (const command of this.commands) {
        if (command.name === "") {
          shouldParse = false;
          const parsed = this.mri(argv.slice(2), command);
          this.setParsedInfo(parsed, command);
          this.emit(\`command:!\`, command);
        }
      }
    }
    if (shouldParse) {
      const parsed = this.mri(argv.slice(2));
      this.setParsedInfo(parsed);
    }
    if (this.options.help && this.showHelpOnExit) {
      this.outputHelp();
      run = false;
      this.unsetMatchedCommand();
    }
    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {
      this.outputVersion();
      run = false;
      this.unsetMatchedCommand();
    }
    const parsedArgv = { args: this.args, options: this.options };
    if (run) {
      this.runMatchedCommand();
    }
    if (!this.matchedCommand && this.args[0]) {
      this.emit("command:*");
    }
    return parsedArgv;
  }
  mri(argv, command) {
    const cliOptions = [
      ...this.globalCommand.options,
      ...command ? command.options : []
    ];
    const mriOptions = getMriOptions(cliOptions);
    let argsAfterDoubleDashes = [];
    const doubleDashesIndex = argv.indexOf("--");
    if (doubleDashesIndex > -1) {
      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
      argv = argv.slice(0, doubleDashesIndex);
    }
    let parsed = mri2(argv, mriOptions);
    parsed = Object.keys(parsed).reduce((res, name) => {
      return __assign(__assign({}, res), {
        [camelcaseOptionName(name)]: parsed[name]
      });
    }, { _: [] });
    const args = parsed._;
    const options = {
      "--": argsAfterDoubleDashes
    };
    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
    let transforms = /* @__PURE__ */ Object.create(null);
    for (const cliOption of cliOptions) {
      if (!ignoreDefault && cliOption.config.default !== undefined) {
        for (const name of cliOption.names) {
          options[name] = cliOption.config.default;
        }
      }
      if (Array.isArray(cliOption.config.type)) {
        if (transforms[cliOption.name] === undefined) {
          transforms[cliOption.name] = /* @__PURE__ */ Object.create(null);
          transforms[cliOption.name]["shouldTransform"] = true;
          transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
        }
      }
    }
    for (const key of Object.keys(parsed)) {
      if (key !== "_") {
        const keys = key.split(".");
        setDotProp(options, keys, parsed[key]);
        setByType(options, transforms);
      }
    }
    return {
      args,
      options
    };
  }
  runMatchedCommand() {
    const { args, options, matchedCommand: command } = this;
    if (!command || !command.commandAction)
      return;
    command.checkUnknownOptions();
    command.checkOptionValue();
    command.checkRequiredArgs();
    const actionArgs = [];
    command.args.forEach((arg, index) => {
      if (arg.variadic) {
        actionArgs.push(args.slice(index));
      } else {
        actionArgs.push(args[index]);
      }
    });
    actionArgs.push(options);
    return command.commandAction.apply(this, actionArgs);
  }
}
const cac = /* @__PURE__ */ __name((name = "") => new CAC(name), "cac");

const version = "0.0.16";

const cli = cac("sitefetch");
cli.command("[url]", "Fetch a site").option("-o, --outfile <path>", "Write the fetched site to a text file").option("--concurrency <number>", "Number of concurrent requests", {
  default: 3
}).option("-m, --match <pattern>", "Only fetch matched pages").option("--content-selector <selector>", "The CSS selector to find content").option("--limit <limit>", "Limit the result to this amount of pages").option("--silent", "Do not print any logs").action(async (url, flags) => {
  if (!url) {
    cli.outputHelp();
    return;
  }
  if (flags.silent) {
    logger.setLevel("silent");
  }
  const pages = await fetchSite(url, {
    concurrency: flags.concurrency,
    match: flags.match && ensureArray(flags.match),
    contentSelector: flags.contentSelector,
    limit: flags.limit
  });
  if (pages.size === 0) {
    logger.warn("No pages found");
    return;
  }
  const pagesArr = [...pages.values()];
  const totalTokenCount = pagesArr.reduce(
    (acc, page) => acc + encode(page.content).length,
    0
  );
  logger.info(
    \`Total token count for \${pages.size} pages: \${formatNumber(
      totalTokenCount
    )}\`
  );
  if (flags.outfile) {
    const output = serializePages(
      pages,
      flags.outfile.endsWith(".json") ? "json" : "text"
    );
    fs.mkdirSync(path.dirname(flags.outfile), { recursive: true });
    fs.writeFileSync(flags.outfile, output, "utf8");
  } else {
    console.log(serializePages(pages, "text"));
  }
});
cli.version(version);
cli.help();
cli.parse();
",
  "import type { Options, FetchSiteResult } from "./types.d.mts";
export declare function fetchSite(url: string, options: Options): Promise<FetchSiteResult>;
export declare function serializePages(pages: FetchSiteResult, format: "json" | "text"): string;
",
  "export { f as fetchSite, s as serializePages } from './packem_shared/index-DjmSPXQS.mjs';
import 'happy-dom';
import 'cheerio';
",
  "type LoggerLevel = "silent" | "warn";
declare class Logger {
    private level?;
    setLevel(level: LoggerLevel): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
}
export declare const logger: Logger;
export {};
",
  "export declare function toMarkdown(html: string): string;
",
  "export type Options = {
    /** How many requests can be made at the same time */
    concurrency?: number;
    /**
     * Match pathname by specific patterns, powered by micromatch
     * Only pages matched by this will be fetched
     */
    match?: string[];
    /**
     * The CSS selector to find content
     */
    contentSelector?: string | ((ctx: {
        pathname: string;
    }) => string | void | undefined);
    /**
     * Limit the result to this amount of pages
     */
    limit?: number;
    /**
     * A custom function to fetch URL
     */
    fetch?: (url: string, init: RequestInit) => Promise<Response>;
};
export type Page = {
    title: string;
    url: string;
    content: string;
};
export type FetchSiteResult = Map<string, Page>;
",
  "export declare function formatNumber(num: number): string;
export declare function matchPath(path: string, pattern: string | string[]): boolean;
export declare function ensureArray<T>(input: T | T[]): T[];
",
  "import { Window } from 'happy-dom';
import Turndown from 'turndown';
import { gfm } from 'turndown-plugin-gfm';
import { load } from 'cheerio';
import micromatch from 'micromatch';

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var eventemitter3 = {exports: {}};

var hasRequiredEventemitter3;

function requireEventemitter3 () {
	if (hasRequiredEventemitter3) return eventemitter3.exports;
	hasRequiredEventemitter3 = 1;
	(function (module) {
		var __defProp = Object.defineProperty;
		var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
		var has = Object.prototype.hasOwnProperty;
		var prefix = "~";
		function Events() {
		}
		__name(Events, "Events");
		if (Object.create) {
		  Events.prototype = /* @__PURE__ */ Object.create(null);
		  if (!new Events().__proto__) prefix = false;
		}
		function EE(fn, context, once2) {
		  this.fn = fn;
		  this.context = context;
		  this.once = once2 || false;
		}
		__name(EE, "EE");
		function addListener(emitter, event, fn, context, once2) {
		  if (typeof fn !== "function") {
		    throw new TypeError("The listener must be a function");
		  }
		  var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
		  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		  else emitter._events[evt] = [emitter._events[evt], listener];
		  return emitter;
		}
		__name(addListener, "addListener");
		function clearEvent(emitter, evt) {
		  if (--emitter._eventsCount === 0) emitter._events = new Events();
		  else delete emitter._events[evt];
		}
		__name(clearEvent, "clearEvent");
		function EventEmitter() {
		  this._events = new Events();
		  this._eventsCount = 0;
		}
		__name(EventEmitter, "EventEmitter");
		EventEmitter.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
		  var names = [], events, name;
		  if (this._eventsCount === 0) return names;
		  for (name in events = this._events) {
		    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		  }
		  if (Object.getOwnPropertySymbols) {
		    return names.concat(Object.getOwnPropertySymbols(events));
		  }
		  return names;
		}, "eventNames");
		EventEmitter.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
		  var evt = prefix ? prefix + event : event, handlers = this._events[evt];
		  if (!handlers) return [];
		  if (handlers.fn) return [handlers.fn];
		  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
		    ee[i] = handlers[i].fn;
		  }
		  return ee;
		}, "listeners");
		EventEmitter.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
		  var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
		  if (!listeners2) return 0;
		  if (listeners2.fn) return 1;
		  return listeners2.length;
		}, "listenerCount");
		EventEmitter.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
		  var evt = prefix ? prefix + event : event;
		  if (!this._events[evt]) return false;
		  var listeners2 = this._events[evt], len = arguments.length, args, i;
		  if (listeners2.fn) {
		    if (listeners2.once) this.removeListener(event, listeners2.fn, undefined, true);
		    switch (len) {
		      case 1:
		        return listeners2.fn.call(listeners2.context), true;
		      case 2:
		        return listeners2.fn.call(listeners2.context, a1), true;
		      case 3:
		        return listeners2.fn.call(listeners2.context, a1, a2), true;
		      case 4:
		        return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
		      case 5:
		        return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
		      case 6:
		        return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
		    }
		    for (i = 1, args = new Array(len - 1); i < len; i++) {
		      args[i - 1] = arguments[i];
		    }
		    listeners2.fn.apply(listeners2.context, args);
		  } else {
		    var length = listeners2.length, j;
		    for (i = 0; i < length; i++) {
		      if (listeners2[i].once) this.removeListener(event, listeners2[i].fn, undefined, true);
		      switch (len) {
		        case 1:
		          listeners2[i].fn.call(listeners2[i].context);
		          break;
		        case 2:
		          listeners2[i].fn.call(listeners2[i].context, a1);
		          break;
		        case 3:
		          listeners2[i].fn.call(listeners2[i].context, a1, a2);
		          break;
		        case 4:
		          listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
		          break;
		        default:
		          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
		            args[j - 1] = arguments[j];
		          }
		          listeners2[i].fn.apply(listeners2[i].context, args);
		      }
		    }
		  }
		  return true;
		}, "emit");
		EventEmitter.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
		  return addListener(this, event, fn, context, false);
		}, "on");
		EventEmitter.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
		  return addListener(this, event, fn, context, true);
		}, "once");
		EventEmitter.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once2) {
		  var evt = prefix ? prefix + event : event;
		  if (!this._events[evt]) return this;
		  if (!fn) {
		    clearEvent(this, evt);
		    return this;
		  }
		  var listeners2 = this._events[evt];
		  if (listeners2.fn) {
		    if (listeners2.fn === fn && (!once2 || listeners2.once) && (!context || listeners2.context === context)) {
		      clearEvent(this, evt);
		    }
		  } else {
		    for (var i = 0, events = [], length = listeners2.length; i < length; i++) {
		      if (listeners2[i].fn !== fn || once2 && !listeners2[i].once || context && listeners2[i].context !== context) {
		        events.push(listeners2[i]);
		      }
		    }
		    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
		    else clearEvent(this, evt);
		  }
		  return this;
		}, "removeListener");
		EventEmitter.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
		  var evt;
		  if (event) {
		    evt = prefix ? prefix + event : event;
		    if (this._events[evt]) clearEvent(this, evt);
		  } else {
		    this._events = new Events();
		    this._eventsCount = 0;
		  }
		  return this;
		}, "removeAllListeners");
		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
		EventEmitter.prototype.addListener = EventEmitter.prototype.on;
		EventEmitter.prefixed = prefix;
		EventEmitter.EventEmitter = EventEmitter;
		{
		  module.exports = EventEmitter;
		} 
	} (eventemitter3));
	return eventemitter3.exports;
}

var eventemitter3Exports = requireEventemitter3();
const EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

var __defProp$7 = Object.defineProperty;
var __name$7 = (target, value) => __defProp$7(target, "name", { value, configurable: true });
class TimeoutError extends Error {
  static {
    __name$7(this, "TimeoutError");
  }
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
}
class AbortError extends Error {
  static {
    __name$7(this, "AbortError");
  }
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
}
const getDOMException = /* @__PURE__ */ __name$7((errorMessage) => globalThis.DOMException === undefined ? new AbortError(errorMessage) : new DOMException(errorMessage), "getDOMException");
const getAbortedReason = /* @__PURE__ */ __name$7((signal) => {
  const reason = signal.reason === undefined ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
}, "getAbortedReason");
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(\`Expected \\\`milliseconds\\\` to be a positive number, got \\\`\${milliseconds}\\\`\`);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      const abortHandler = /* @__PURE__ */ __name$7(() => {
        reject(getAbortedReason(signal));
      }, "abortHandler");
      signal.addEventListener("abort", abortHandler, { once: true });
      promise.finally(() => {
        signal.removeEventListener("abort", abortHandler);
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(undefined, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message === false) {
        resolve();
      } else if (message instanceof Error) {
        reject(message);
      } else {
        timeoutError.message = message ?? \`Promise timed out after \${milliseconds} milliseconds\`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(undefined, timer);
    timer = undefined;
  };
  return cancelablePromise;
}
__name$7(pTimeout, "pTimeout");

var __defProp$6 = Object.defineProperty;
var __name$6 = (target, value) => __defProp$6(target, "name", { value, configurable: true });
function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}
__name$6(lowerBound, "lowerBound");

var __defProp$5 = Object.defineProperty;
var __name$5 = (target, value) => __defProp$5(target, "name", { value, configurable: true });
class PriorityQueue {
  static {
    __name$5(this, "PriorityQueue");
  }
  #queue = [];
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      id: options.id,
      run
    };
    if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {
      this.#queue.push(element);
      return;
    }
    const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);
    this.#queue.splice(index, 0, element);
  }
  setPriority(id, priority) {
    const index = this.#queue.findIndex((element) => element.id === id);
    if (index === -1) {
      throw new ReferenceError(\`No promise function with the id "\${id}" exists in the queue.\`);
    }
    const [item] = this.#queue.splice(index, 1);
    this.enqueue(item.run, { priority, id });
  }
  dequeue() {
    const item = this.#queue.shift();
    return item?.run;
  }
  filter(options) {
    return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return this.#queue.length;
  }
}

var __defProp$4 = Object.defineProperty;
var __name$4 = (target, value) => __defProp$4(target, "name", { value, configurable: true });
class PQueue extends EventEmitter {
  static {
    __name$4(this, "PQueue");
  }
  #carryoverConcurrencyCount;
  #isIntervalIgnored;
  #intervalCount = 0;
  #intervalCap;
  #interval;
  #intervalEnd = 0;
  #intervalId;
  #timeoutId;
  #queue;
  #queueClass;
  #pending = 0;
  // The \`!\` is needed because of https://github.com/microsoft/TypeScript/issues/32194
  #concurrency;
  #isPaused;
  #throwOnTimeout;
  // Use to assign a unique identifier to a promise function, if not explicitly specified
  #idAssigner = 1n;
  /**
      Per-operation timeout in milliseconds. Operations fulfill once \`timeout\` elapses if they haven't already.
  
      Applies to each future operation.
      */
  timeout;
  // TODO: The \`throwOnTimeout\` option should affect the return types of \`add()\` and \`addAll()\`
  constructor(options) {
    super();
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(\`Expected \\\`intervalCap\\\` to be a number from 1 and up, got \\\`\${options.intervalCap?.toString() ?? ""}\\\` (\${typeof options.intervalCap})\`);
    }
    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(\`Expected \\\`interval\\\` to be a finite number >= 0, got \\\`\${options.interval?.toString() ?? ""}\\\` (\${typeof options.interval})\`);
    }
    this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
    this.#intervalCap = options.intervalCap;
    this.#interval = options.interval;
    this.#queue = new options.queueClass();
    this.#queueClass = options.queueClass;
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    this.#throwOnTimeout = options.throwOnTimeout === true;
    this.#isPaused = options.autoStart === false;
  }
  get #doesIntervalAllowAnother() {
    return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
  }
  get #doesConcurrentAllowAnother() {
    return this.#pending < this.#concurrency;
  }
  #next() {
    this.#pending--;
    this.#tryToStartAnother();
    this.emit("next");
  }
  #onResumeInterval() {
    this.#onInterval();
    this.#initializeIntervalIfNeeded();
    this.#timeoutId = undefined;
  }
  get #isIntervalPaused() {
    const now = Date.now();
    if (this.#intervalId === undefined) {
      const delay = this.#intervalEnd - now;
      if (delay < 0) {
        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
      } else {
        if (this.#timeoutId === undefined) {
          this.#timeoutId = setTimeout(() => {
            this.#onResumeInterval();
          }, delay);
        }
        return true;
      }
    }
    return false;
  }
  #tryToStartAnother() {
    if (this.#queue.size === 0) {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
      }
      this.#intervalId = undefined;
      this.emit("empty");
      if (this.#pending === 0) {
        this.emit("idle");
      }
      return false;
    }
    if (!this.#isPaused) {
      const canInitializeInterval = !this.#isIntervalPaused;
      if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
        const job = this.#queue.dequeue();
        if (!job) {
          return false;
        }
        this.emit("active");
        job();
        if (canInitializeInterval) {
          this.#initializeIntervalIfNeeded();
        }
        return true;
      }
    }
    return false;
  }
  #initializeIntervalIfNeeded() {
    if (this.#isIntervalIgnored || this.#intervalId !== undefined) {
      return;
    }
    this.#intervalId = setInterval(() => {
      this.#onInterval();
    }, this.#interval);
    this.#intervalEnd = Date.now() + this.#interval;
  }
  #onInterval() {
    if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
      clearInterval(this.#intervalId);
      this.#intervalId = undefined;
    }
    this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
    this.#processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  #processQueue() {
    while (this.#tryToStartAnother()) {
    }
  }
  get concurrency() {
    return this.#concurrency;
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(\`Expected \\\`concurrency\\\` to be a number from 1 and up, got \\\`\${newConcurrency}\\\` (\${typeof newConcurrency})\`);
    }
    this.#concurrency = newConcurrency;
    this.#processQueue();
  }
  async #throwOnAbort(signal) {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(signal.reason);
      }, { once: true });
    });
  }
  /**
      Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
  
      For example, this can be used to prioritize a promise function to run earlier.
  
      \`\`\`js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 0, id: '🦀'});
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦄', {priority: 1});
  
      queue.setPriority('🦀', 2);
      \`\`\`
  
      In this case, the promise function with \`id: '🦀'\` runs second.
  
      You can also deprioritize a promise function to delay its execution:
  
      \`\`\`js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 1, id: '🦀'});
      queue.add(async () => '🦄');
      queue.add(async () => '🦄', {priority: 0});
  
      queue.setPriority('🦀', -1);
      \`\`\`
      Here, the promise function with \`id: '🦀'\` executes last.
      */
  setPriority(id, priority) {
    this.#queue.setPriority(id, priority);
  }
  async add(function_, options = {}) {
    options.id ??= (this.#idAssigner++).toString();
    options = {
      timeout: this.timeout,
      throwOnTimeout: this.#throwOnTimeout,
      ...options
    };
    return new Promise((resolve, reject) => {
      this.#queue.enqueue(async () => {
        this.#pending++;
        this.#intervalCount++;
        try {
          options.signal?.throwIfAborted();
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
          }
          if (options.signal) {
            operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          this.#next();
        }
      }, options);
      this.emit("add");
      this.#tryToStartAnother();
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via \`options.autoStart = false\` or by \`.pause()\` method.)
  */
  start() {
    if (!this.#isPaused) {
      return this;
    }
    this.#isPaused = false;
    this.#processQueue();
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this.#isPaused = true;
  }
  /**
  Clear the queue.
  */
  clear() {
    this.#queue = new this.#queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: \`queue.size < limit\`.
  
      If you want to avoid having the queue grow beyond a certain size you can \`await queue.onSizeLessThan()\` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to \`concurrency\` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (this.#queue.size < limit) {
      return;
    }
    await this.#onEvent("next", () => this.#queue.size < limit);
  }
  /**
      The difference with \`.onEmpty\` is that \`.onIdle\` guarantees that all work from the queue has finished. \`.onEmpty\` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; \`queue.size === 0 && queue.pending === 0\`.
      */
  async onIdle() {
    if (this.#pending === 0 && this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("idle");
  }
  async #onEvent(event, filter) {
    return new Promise((resolve) => {
      const listener = /* @__PURE__ */ __name$4(() => {
        if (filter && !filter()) {
          return;
        }
        this.off(event, listener);
        resolve();
      }, "listener");
      this.on(event, listener);
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return this.#queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return this.#queue.filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return this.#pending;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this.#isPaused;
  }
}

var Readability = {exports: {}};

var hasRequiredReadability$1;

function requireReadability$1 () {
	if (hasRequiredReadability$1) return Readability.exports;
	hasRequiredReadability$1 = 1;
	(function (module) {
		var __defProp = Object.defineProperty;
		var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
		function Readability(doc, options) {
		  if (options && options.documentElement) {
		    doc = options;
		    options = arguments[2];
		  } else if (!doc || !doc.documentElement) {
		    throw new Error("First argument to Readability constructor should be a document object.");
		  }
		  options = options || {};
		  this._doc = doc;
		  this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
		  this._articleTitle = null;
		  this._articleByline = null;
		  this._articleDir = null;
		  this._articleSiteName = null;
		  this._attempts = [];
		  this._debug = !!options.debug;
		  this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
		  this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
		  this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
		  this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);
		  this._keepClasses = !!options.keepClasses;
		  this._serializer = options.serializer || function(el) {
		    return el.innerHTML;
		  };
		  this._disableJSONLD = !!options.disableJSONLD;
		  this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;
		  this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;
		  if (this._debug) {
		    let logNode = /* @__PURE__ */ __name(function(node) {
		      if (node.nodeType == node.TEXT_NODE) {
		        return \`\${node.nodeName} ("\${node.textContent}")\`;
		      }
		      let attrPairs = Array.from(node.attributes || [], function(attr) {
		        return \`\${attr.name}="\${attr.value}"\`;
		      }).join(" ");
		      return \`<\${node.localName} \${attrPairs}>\`;
		    }, "logNode");
		    this.log = function() {
		      if (typeof console !== "undefined") {
		        let args = Array.from(arguments, (arg) => {
		          if (arg && arg.nodeType == this.ELEMENT_NODE) {
		            return logNode(arg);
		          }
		          return arg;
		        });
		        args.unshift("Reader: (Readability)");
		        console.log.apply(console, args);
		      } else if (typeof dump !== "undefined") {
		        var msg = Array.prototype.map.call(arguments, function(x) {
		          return x && x.nodeName ? logNode(x) : x;
		        }).join(" ");
		        dump("Reader: (Readability) " + msg + "\\n");
		      }
		    };
		  } else {
		    this.log = function() {
		    };
		  }
		}
		__name(Readability, "Readability");
		Readability.prototype = {
		  FLAG_STRIP_UNLIKELYS: 1,
		  FLAG_WEIGHT_CLASSES: 2,
		  FLAG_CLEAN_CONDITIONALLY: 4,
		  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
		  ELEMENT_NODE: 1,
		  TEXT_NODE: 3,
		  // Max number of nodes supported by this parser. Default: 0 (no limit)
		  DEFAULT_MAX_ELEMS_TO_PARSE: 0,
		  // The number of top candidates to consider when analysing how
		  // tight the competition is among candidates.
		  DEFAULT_N_TOP_CANDIDATES: 5,
		  // Element tags to score by default.
		  DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
		  // The default number of chars an article must have in order to return a result
		  DEFAULT_CHAR_THRESHOLD: 500,
		  // All of the regular expressions in use within readability.
		  // Defined up here so we don't instantiate them repeatedly in loops.
		  REGEXPS: {
		    // NOTE: These two regular expressions are duplicated in
		    // Readability-readerable.js. Please keep both copies in sync.
		    unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
		    okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
		    positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
		    negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,
		    extraneous: /print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single|utility/i,
		    byline: /byline|author|dateline|writtenby|p-author/i,
		    replaceFonts: /<(\\/?)font[^>]*>/gi,
		    normalize: /\\s{2,}/g,
		    videos: /\\/\\/(www\\.)?((dailymotion|youtube|youtube-nocookie|player\\.vimeo|v\\.qq)\\.com|(archive|upload\\.wikimedia)\\.org|player\\.twitch\\.tv)/i,
		    shareElements: /(\\b|_)(share|sharedaddy)(\\b|_)/i,
		    nextLink: /(next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/i,
		    prevLink: /(prev|earl|old|new|<|«)/i,
		    tokenize: /\\W+/g,
		    whitespace: /^\\s*$/,
		    hasContent: /\\S$/,
		    hashUrl: /^#.+/,
		    srcsetUrl: /(\\S+)(\\s+[\\d.]+[xw])?(\\s*(?:,|$))/g,
		    b64DataUrl: /^data:\\s*([^\\s;,]+)\\s*;\\s*base64\\s*,/i,
		    // Commas as used in Latin, Sindhi, Chinese and various other scripts.
		    // see: https://en.wikipedia.org/wiki/Comma#Comma_variants
		    commas: /\\u002C|\\u060C|\\uFE50|\\uFE10|\\uFE11|\\u2E41|\\u2E34|\\u2E32|\\uFF0C/g,
		    // See: https://schema.org/Article
		    jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/
		  },
		  UNLIKELY_ROLES: ["menu", "menubar", "complementary", "navigation", "alert", "alertdialog", "dialog"],
		  DIV_TO_P_ELEMS: /* @__PURE__ */ new Set(["BLOCKQUOTE", "DL", "DIV", "IMG", "OL", "P", "PRE", "TABLE", "UL"]),
		  ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P"],
		  PRESENTATIONAL_ATTRIBUTES: ["align", "background", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "hspace", "rules", "style", "valign", "vspace"],
		  DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
		  // The commented out elements qualify as phrasing content but tend to be
		  // removed by readability when put into paragraphs, so we ignore them here.
		  PHRASING_ELEMS: [
		    // "CANVAS", "IFRAME", "SVG", "VIDEO",
		    "ABBR",
		    "AUDIO",
		    "B",
		    "BDO",
		    "BR",
		    "BUTTON",
		    "CITE",
		    "CODE",
		    "DATA",
		    "DATALIST",
		    "DFN",
		    "EM",
		    "EMBED",
		    "I",
		    "IMG",
		    "INPUT",
		    "KBD",
		    "LABEL",
		    "MARK",
		    "MATH",
		    "METER",
		    "NOSCRIPT",
		    "OBJECT",
		    "OUTPUT",
		    "PROGRESS",
		    "Q",
		    "RUBY",
		    "SAMP",
		    "SCRIPT",
		    "SELECT",
		    "SMALL",
		    "SPAN",
		    "STRONG",
		    "SUB",
		    "SUP",
		    "TEXTAREA",
		    "TIME",
		    "VAR",
		    "WBR"
		  ],
		  // These are the classes that readability sets itself.
		  CLASSES_TO_PRESERVE: ["page"],
		  // These are the list of HTML entities that need to be escaped.
		  HTML_ESCAPE_MAP: {
		    "lt": "<",
		    "gt": ">",
		    "amp": "&",
		    "quot": '"',
		    "apos": "'"
		  },
		  /**
		   * Run any post-process modifications to article content as necessary.
		   *
		   * @param Element
		   * @return void
		  **/
		  _postProcessContent: /* @__PURE__ */ __name(function(articleContent) {
		    this._fixRelativeUris(articleContent);
		    this._simplifyNestedElements(articleContent);
		    if (!this._keepClasses) {
		      this._cleanClasses(articleContent);
		    }
		  }, "_postProcessContent"),
		  /**
		   * Iterates over a NodeList, calls \`filterFn\` for each node and removes node
		   * if function returned \`true\`.
		   *
		   * If function is not passed, removes all the nodes in node list.
		   *
		   * @param NodeList nodeList The nodes to operate on
		   * @param Function filterFn the function to use as a filter
		   * @return void
		   */
		  _removeNodes: /* @__PURE__ */ __name(function(nodeList, filterFn) {
		    if (this._docJSDOMParser && nodeList._isLiveNodeList) {
		      throw new Error("Do not pass live node lists to _removeNodes");
		    }
		    for (var i = nodeList.length - 1; i >= 0; i--) {
		      var node = nodeList[i];
		      var parentNode = node.parentNode;
		      if (parentNode) {
		        if (!filterFn || filterFn.call(this, node, i, nodeList)) {
		          parentNode.removeChild(node);
		        }
		      }
		    }
		  }, "_removeNodes"),
		  /**
		   * Iterates over a NodeList, and calls _setNodeTag for each node.
		   *
		   * @param NodeList nodeList The nodes to operate on
		   * @param String newTagName the new tag name to use
		   * @return void
		   */
		  _replaceNodeTags: /* @__PURE__ */ __name(function(nodeList, newTagName) {
		    if (this._docJSDOMParser && nodeList._isLiveNodeList) {
		      throw new Error("Do not pass live node lists to _replaceNodeTags");
		    }
		    for (const node of nodeList) {
		      this._setNodeTag(node, newTagName);
		    }
		  }, "_replaceNodeTags"),
		  /**
		   * Iterate over a NodeList, which doesn't natively fully implement the Array
		   * interface.
		   *
		   * For convenience, the current object context is applied to the provided
		   * iterate function.
		   *
		   * @param  NodeList nodeList The NodeList.
		   * @param  Function fn       The iterate function.
		   * @return void
		   */
		  _forEachNode: /* @__PURE__ */ __name(function(nodeList, fn) {
		    Array.prototype.forEach.call(nodeList, fn, this);
		  }, "_forEachNode"),
		  /**
		   * Iterate over a NodeList, and return the first node that passes
		   * the supplied test function
		   *
		   * For convenience, the current object context is applied to the provided
		   * test function.
		   *
		   * @param  NodeList nodeList The NodeList.
		   * @param  Function fn       The test function.
		   * @return void
		   */
		  _findNode: /* @__PURE__ */ __name(function(nodeList, fn) {
		    return Array.prototype.find.call(nodeList, fn, this);
		  }, "_findNode"),
		  /**
		   * Iterate over a NodeList, return true if any of the provided iterate
		   * function calls returns true, false otherwise.
		   *
		   * For convenience, the current object context is applied to the
		   * provided iterate function.
		   *
		   * @param  NodeList nodeList The NodeList.
		   * @param  Function fn       The iterate function.
		   * @return Boolean
		   */
		  _someNode: /* @__PURE__ */ __name(function(nodeList, fn) {
		    return Array.prototype.some.call(nodeList, fn, this);
		  }, "_someNode"),
		  /**
		   * Iterate over a NodeList, return true if all of the provided iterate
		   * function calls return true, false otherwise.
		   *
		   * For convenience, the current object context is applied to the
		   * provided iterate function.
		   *
		   * @param  NodeList nodeList The NodeList.
		   * @param  Function fn       The iterate function.
		   * @return Boolean
		   */
		  _everyNode: /* @__PURE__ */ __name(function(nodeList, fn) {
		    return Array.prototype.every.call(nodeList, fn, this);
		  }, "_everyNode"),
		  /**
		   * Concat all nodelists passed as arguments.
		   *
		   * @return ...NodeList
		   * @return Array
		   */
		  _concatNodeLists: /* @__PURE__ */ __name(function() {
		    var slice = Array.prototype.slice;
		    var args = slice.call(arguments);
		    var nodeLists = args.map(function(list) {
		      return slice.call(list);
		    });
		    return Array.prototype.concat.apply([], nodeLists);
		  }, "_concatNodeLists"),
		  _getAllNodesWithTag: /* @__PURE__ */ __name(function(node, tagNames) {
		    if (node.querySelectorAll) {
		      return node.querySelectorAll(tagNames.join(","));
		    }
		    return [].concat.apply([], tagNames.map(function(tag) {
		      var collection = node.getElementsByTagName(tag);
		      return Array.isArray(collection) ? collection : Array.from(collection);
		    }));
		  }, "_getAllNodesWithTag"),
		  /**
		   * Removes the class="" attribute from every element in the given
		   * subtree, except those that match CLASSES_TO_PRESERVE and
		   * the classesToPreserve array from the options object.
		   *
		   * @param Element
		   * @return void
		   */
		  _cleanClasses: /* @__PURE__ */ __name(function(node) {
		    var classesToPreserve = this._classesToPreserve;
		    var className = (node.getAttribute("class") || "").split(/\\s+/).filter(function(cls) {
		      return classesToPreserve.indexOf(cls) != -1;
		    }).join(" ");
		    if (className) {
		      node.setAttribute("class", className);
		    } else {
		      node.removeAttribute("class");
		    }
		    for (node = node.firstElementChild; node; node = node.nextElementSibling) {
		      this._cleanClasses(node);
		    }
		  }, "_cleanClasses"),
		  /**
		   * Converts each <a> and <img> uri in the given element to an absolute URI,
		   * ignoring #ref URIs.
		   *
		   * @param Element
		   * @return void
		   */
		  _fixRelativeUris: /* @__PURE__ */ __name(function(articleContent) {
		    var baseURI = this._doc.baseURI;
		    var documentURI = this._doc.documentURI;
		    function toAbsoluteURI(uri) {
		      if (baseURI == documentURI && uri.charAt(0) == "#") {
		        return uri;
		      }
		      try {
		        return new URL(uri, baseURI).href;
		      } catch (ex) {
		      }
		      return uri;
		    }
		    __name(toAbsoluteURI, "toAbsoluteURI");
		    var links = this._getAllNodesWithTag(articleContent, ["a"]);
		    this._forEachNode(links, function(link) {
		      var href = link.getAttribute("href");
		      if (href) {
		        if (href.indexOf("javascript:") === 0) {
		          if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
		            var text = this._doc.createTextNode(link.textContent);
		            link.parentNode.replaceChild(text, link);
		          } else {
		            var container = this._doc.createElement("span");
		            while (link.firstChild) {
		              container.appendChild(link.firstChild);
		            }
		            link.parentNode.replaceChild(container, link);
		          }
		        } else {
		          link.setAttribute("href", toAbsoluteURI(href));
		        }
		      }
		    });
		    var medias = this._getAllNodesWithTag(articleContent, [
		      "img",
		      "picture",
		      "figure",
		      "video",
		      "audio",
		      "source"
		    ]);
		    this._forEachNode(medias, function(media) {
		      var src = media.getAttribute("src");
		      var poster = media.getAttribute("poster");
		      var srcset = media.getAttribute("srcset");
		      if (src) {
		        media.setAttribute("src", toAbsoluteURI(src));
		      }
		      if (poster) {
		        media.setAttribute("poster", toAbsoluteURI(poster));
		      }
		      if (srcset) {
		        var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_, p1, p2, p3) {
		          return toAbsoluteURI(p1) + (p2 || "") + p3;
		        });
		        media.setAttribute("srcset", newSrcset);
		      }
		    });
		  }, "_fixRelativeUris"),
		  _simplifyNestedElements: /* @__PURE__ */ __name(function(articleContent) {
		    var node = articleContent;
		    while (node) {
		      if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
		        if (this._isElementWithoutContent(node)) {
		          node = this._removeAndGetNext(node);
		          continue;
		        } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
		          var child = node.children[0];
		          for (var i = 0; i < node.attributes.length; i++) {
		            child.setAttribute(node.attributes[i].name, node.attributes[i].value);
		          }
		          node.parentNode.replaceChild(child, node);
		          node = child;
		          continue;
		        }
		      }
		      node = this._getNextNode(node);
		    }
		  }, "_simplifyNestedElements"),
		  /**
		   * Get the article title as an H1.
		   *
		   * @return string
		   **/
		  _getArticleTitle: /* @__PURE__ */ __name(function() {
		    var doc = this._doc;
		    var curTitle = "";
		    var origTitle = "";
		    try {
		      curTitle = origTitle = doc.title.trim();
		      if (typeof curTitle !== "string")
		        curTitle = origTitle = this._getInnerText(doc.getElementsByTagName("title")[0]);
		    } catch (e) {
		    }
		    var titleHadHierarchicalSeparators = false;
		    function wordCount(str) {
		      return str.split(/\\s+/).length;
		    }
		    __name(wordCount, "wordCount");
		    if (/ [\\|\\-\\\\\\/>»] /.test(curTitle)) {
		      titleHadHierarchicalSeparators = / [\\\\\\/>»] /.test(curTitle);
		      curTitle = origTitle.replace(/(.*)[\\|\\-\\\\\\/>»] .*/gi, "$1");
		      if (wordCount(curTitle) < 3)
		        curTitle = origTitle.replace(/[^\\|\\-\\\\\\/>»]*[\\|\\-\\\\\\/>»](.*)/gi, "$1");
		    } else if (curTitle.indexOf(": ") !== -1) {
		      var headings = this._concatNodeLists(
		        doc.getElementsByTagName("h1"),
		        doc.getElementsByTagName("h2")
		      );
		      var trimmedTitle = curTitle.trim();
		      var match = this._someNode(headings, function(heading) {
		        return heading.textContent.trim() === trimmedTitle;
		      });
		      if (!match) {
		        curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1);
		        if (wordCount(curTitle) < 3) {
		          curTitle = origTitle.substring(origTitle.indexOf(":") + 1);
		        } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
		          curTitle = origTitle;
		        }
		      }
		    } else if (curTitle.length > 150 || curTitle.length < 15) {
		      var hOnes = doc.getElementsByTagName("h1");
		      if (hOnes.length === 1)
		        curTitle = this._getInnerText(hOnes[0]);
		    }
		    curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " ");
		    var curTitleWordCount = wordCount(curTitle);
		    if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\\|\\-\\\\\\/>»]+/g, "")) - 1)) {
		      curTitle = origTitle;
		    }
		    return curTitle;
		  }, "_getArticleTitle"),
		  /**
		   * Prepare the HTML document for readability to scrape it.
		   * This includes things like stripping javascript, CSS, and handling terrible markup.
		   *
		   * @return void
		   **/
		  _prepDocument: /* @__PURE__ */ __name(function() {
		    var doc = this._doc;
		    this._removeNodes(this._getAllNodesWithTag(doc, ["style"]));
		    if (doc.body) {
		      this._replaceBrs(doc.body);
		    }
		    this._replaceNodeTags(this._getAllNodesWithTag(doc, ["font"]), "SPAN");
		  }, "_prepDocument"),
		  /**
		   * Finds the next node, starting from the given node, and ignoring
		   * whitespace in between. If the given node is an element, the same node is
		   * returned.
		   */
		  _nextNode: /* @__PURE__ */ __name(function(node) {
		    var next = node;
		    while (next && next.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next.textContent)) {
		      next = next.nextSibling;
		    }
		    return next;
		  }, "_nextNode"),
		  /**
		   * Replaces 2 or more successive <br> elements with a single <p>.
		   * Whitespace between <br> elements are ignored. For example:
		   *   <div>foo<br>bar<br> <br><br>abc</div>
		   * will become:
		   *   <div>foo<br>bar<p>abc</p></div>
		   */
		  _replaceBrs: /* @__PURE__ */ __name(function(elem) {
		    this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function(br) {
		      var next = br.nextSibling;
		      var replaced = false;
		      while ((next = this._nextNode(next)) && next.tagName == "BR") {
		        replaced = true;
		        var brSibling = next.nextSibling;
		        next.parentNode.removeChild(next);
		        next = brSibling;
		      }
		      if (replaced) {
		        var p = this._doc.createElement("p");
		        br.parentNode.replaceChild(p, br);
		        next = p.nextSibling;
		        while (next) {
		          if (next.tagName == "BR") {
		            var nextElem = this._nextNode(next.nextSibling);
		            if (nextElem && nextElem.tagName == "BR")
		              break;
		          }
		          if (!this._isPhrasingContent(next))
		            break;
		          var sibling = next.nextSibling;
		          p.appendChild(next);
		          next = sibling;
		        }
		        while (p.lastChild && this._isWhitespace(p.lastChild)) {
		          p.removeChild(p.lastChild);
		        }
		        if (p.parentNode.tagName === "P")
		          this._setNodeTag(p.parentNode, "DIV");
		      }
		    });
		  }, "_replaceBrs"),
		  _setNodeTag: /* @__PURE__ */ __name(function(node, tag) {
		    this.log("_setNodeTag", node, tag);
		    if (this._docJSDOMParser) {
		      node.localName = tag.toLowerCase();
		      node.tagName = tag.toUpperCase();
		      return node;
		    }
		    var replacement = node.ownerDocument.createElement(tag);
		    while (node.firstChild) {
		      replacement.appendChild(node.firstChild);
		    }
		    node.parentNode.replaceChild(replacement, node);
		    if (node.readability)
		      replacement.readability = node.readability;
		    for (var i = 0; i < node.attributes.length; i++) {
		      try {
		        replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);
		      } catch (ex) {
		      }
		    }
		    return replacement;
		  }, "_setNodeTag"),
		  /**
		   * Prepare the article node for display. Clean out any inline styles,
		   * iframes, forms, strip extraneous <p> tags, etc.
		   *
		   * @param Element
		   * @return void
		   **/
		  _prepArticle: /* @__PURE__ */ __name(function(articleContent) {
		    this._cleanStyles(articleContent);
		    this._markDataTables(articleContent);
		    this._fixLazyImages(articleContent);
		    this._cleanConditionally(articleContent, "form");
		    this._cleanConditionally(articleContent, "fieldset");
		    this._clean(articleContent, "object");
		    this._clean(articleContent, "embed");
		    this._clean(articleContent, "footer");
		    this._clean(articleContent, "link");
		    this._clean(articleContent, "aside");
		    var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;
		    this._forEachNode(articleContent.children, function(topCandidate) {
		      this._cleanMatchedNodes(topCandidate, function(node, matchString) {
		        return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
		      });
		    });
		    this._clean(articleContent, "iframe");
		    this._clean(articleContent, "input");
		    this._clean(articleContent, "textarea");
		    this._clean(articleContent, "select");
		    this._clean(articleContent, "button");
		    this._cleanHeaders(articleContent);
		    this._cleanConditionally(articleContent, "table");
		    this._cleanConditionally(articleContent, "ul");
		    this._cleanConditionally(articleContent, "div");
		    this._replaceNodeTags(this._getAllNodesWithTag(articleContent, ["h1"]), "h2");
		    this._removeNodes(this._getAllNodesWithTag(articleContent, ["p"]), function(paragraph) {
		      var imgCount = paragraph.getElementsByTagName("img").length;
		      var embedCount = paragraph.getElementsByTagName("embed").length;
		      var objectCount = paragraph.getElementsByTagName("object").length;
		      var iframeCount = paragraph.getElementsByTagName("iframe").length;
		      var totalCount = imgCount + embedCount + objectCount + iframeCount;
		      return totalCount === 0 && !this._getInnerText(paragraph, false);
		    });
		    this._forEachNode(this._getAllNodesWithTag(articleContent, ["br"]), function(br) {
		      var next = this._nextNode(br.nextSibling);
		      if (next && next.tagName == "P")
		        br.parentNode.removeChild(br);
		    });
		    this._forEachNode(this._getAllNodesWithTag(articleContent, ["table"]), function(table) {
		      var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;
		      if (this._hasSingleTagInsideElement(tbody, "TR")) {
		        var row = tbody.firstElementChild;
		        if (this._hasSingleTagInsideElement(row, "TD")) {
		          var cell = row.firstElementChild;
		          cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? "P" : "DIV");
		          table.parentNode.replaceChild(cell, table);
		        }
		      }
		    });
		  }, "_prepArticle"),
		  /**
		   * Initialize a node with the readability object. Also checks the
		   * className/id for special names to add to its score.
		   *
		   * @param Element
		   * @return void
		  **/
		  _initializeNode: /* @__PURE__ */ __name(function(node) {
		    node.readability = { "contentScore": 0 };
		    switch (node.tagName) {
		      case "DIV":
		        node.readability.contentScore += 5;
		        break;
		      case "PRE":
		      case "TD":
		      case "BLOCKQUOTE":
		        node.readability.contentScore += 3;
		        break;
		      case "ADDRESS":
		      case "OL":
		      case "UL":
		      case "DL":
		      case "DD":
		      case "DT":
		      case "LI":
		      case "FORM":
		        node.readability.contentScore -= 3;
		        break;
		      case "H1":
		      case "H2":
		      case "H3":
		      case "H4":
		      case "H5":
		      case "H6":
		      case "TH":
		        node.readability.contentScore -= 5;
		        break;
		    }
		    node.readability.contentScore += this._getClassWeight(node);
		  }, "_initializeNode"),
		  _removeAndGetNext: /* @__PURE__ */ __name(function(node) {
		    var nextNode = this._getNextNode(node, true);
		    node.parentNode.removeChild(node);
		    return nextNode;
		  }, "_removeAndGetNext"),
		  /**
		   * Traverse the DOM from node to node, starting at the node passed in.
		   * Pass true for the second parameter to indicate this node itself
		   * (and its kids) are going away, and we want the next node over.
		   *
		   * Calling this in a loop will traverse the DOM depth-first.
		   */
		  _getNextNode: /* @__PURE__ */ __name(function(node, ignoreSelfAndKids) {
		    if (!ignoreSelfAndKids && node.firstElementChild) {
		      return node.firstElementChild;
		    }
		    if (node.nextElementSibling) {
		      return node.nextElementSibling;
		    }
		    do {
		      node = node.parentNode;
		    } while (node && !node.nextElementSibling);
		    return node && node.nextElementSibling;
		  }, "_getNextNode"),
		  // compares second text to first one
		  // 1 = same text, 0 = completely different text
		  // works the way that it splits both texts into words and then finds words that are unique in second text
		  // the result is given by the lower length of unique parts
		  _textSimilarity: /* @__PURE__ */ __name(function(textA, textB) {
		    var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
		    var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
		    if (!tokensA.length || !tokensB.length) {
		      return 0;
		    }
		    var uniqTokensB = tokensB.filter((token) => !tokensA.includes(token));
		    var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
		    return 1 - distanceB;
		  }, "_textSimilarity"),
		  _checkByline: /* @__PURE__ */ __name(function(node, matchString) {
		    if (this._articleByline) {
		      return false;
		    }
		    if (node.getAttribute !== undefined) {
		      var rel = node.getAttribute("rel");
		      var itemprop = node.getAttribute("itemprop");
		    }
		    if ((rel === "author" || itemprop && itemprop.indexOf("author") !== -1 || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {
		      this._articleByline = node.textContent.trim();
		      return true;
		    }
		    return false;
		  }, "_checkByline"),
		  _getNodeAncestors: /* @__PURE__ */ __name(function(node, maxDepth) {
		    maxDepth = maxDepth || 0;
		    var i = 0, ancestors = [];
		    while (node.parentNode) {
		      ancestors.push(node.parentNode);
		      if (maxDepth && ++i === maxDepth)
		        break;
		      node = node.parentNode;
		    }
		    return ancestors;
		  }, "_getNodeAncestors"),
		  /***
		   * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
		   *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
		   *
		   * @param page a document to run upon. Needs to be a full document, complete with body.
		   * @return Element
		  **/
		  _grabArticle: /* @__PURE__ */ __name(function(page) {
		    this.log("**** grabArticle ****");
		    var doc = this._doc;
		    var isPaging = page !== null;
		    page = page ? page : this._doc.body;
		    if (!page) {
		      this.log("No body found in document. Abort.");
		      return null;
		    }
		    var pageCacheHtml = page.innerHTML;
		    while (true) {
		      this.log("Starting grabArticle loop");
		      var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);
		      var elementsToScore = [];
		      var node = this._doc.documentElement;
		      let shouldRemoveTitleHeader = true;
		      while (node) {
		        if (node.tagName === "HTML") {
		          this._articleLang = node.getAttribute("lang");
		        }
		        var matchString = node.className + " " + node.id;
		        if (!this._isProbablyVisible(node)) {
		          this.log("Removing hidden node - " + matchString);
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (node.getAttribute("aria-modal") == "true" && node.getAttribute("role") == "dialog") {
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (this._checkByline(node, matchString)) {
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
		          this.log("Removing header: ", node.textContent.trim(), this._articleTitle.trim());
		          shouldRemoveTitleHeader = false;
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (stripUnlikelyCandidates) {
		          if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
		            this.log("Removing unlikely candidate - " + matchString);
		            node = this._removeAndGetNext(node);
		            continue;
		          }
		          if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
		            this.log("Removing content with role " + node.getAttribute("role") + " - " + matchString);
		            node = this._removeAndGetNext(node);
		            continue;
		          }
		        }
		        if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {
		          elementsToScore.push(node);
		        }
		        if (node.tagName === "DIV") {
		          var p = null;
		          var childNode = node.firstChild;
		          while (childNode) {
		            var nextSibling = childNode.nextSibling;
		            if (this._isPhrasingContent(childNode)) {
		              if (p !== null) {
		                p.appendChild(childNode);
		              } else if (!this._isWhitespace(childNode)) {
		                p = doc.createElement("p");
		                node.replaceChild(p, childNode);
		                p.appendChild(childNode);
		              }
		            } else if (p !== null) {
		              while (p.lastChild && this._isWhitespace(p.lastChild)) {
		                p.removeChild(p.lastChild);
		              }
		              p = null;
		            }
		            childNode = nextSibling;
		          }
		          if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
		            var newNode = node.children[0];
		            node.parentNode.replaceChild(newNode, node);
		            node = newNode;
		            elementsToScore.push(node);
		          } else if (!this._hasChildBlockElement(node)) {
		            node = this._setNodeTag(node, "P");
		            elementsToScore.push(node);
		          }
		        }
		        node = this._getNextNode(node);
		      }
		      var candidates = [];
		      this._forEachNode(elementsToScore, function(elementToScore) {
		        if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined")
		          return;
		        var innerText = this._getInnerText(elementToScore);
		        if (innerText.length < 25)
		          return;
		        var ancestors2 = this._getNodeAncestors(elementToScore, 5);
		        if (ancestors2.length === 0)
		          return;
		        var contentScore = 0;
		        contentScore += 1;
		        contentScore += innerText.split(this.REGEXPS.commas).length;
		        contentScore += Math.min(Math.floor(innerText.length / 100), 3);
		        this._forEachNode(ancestors2, function(ancestor, level) {
		          if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined")
		            return;
		          if (typeof ancestor.readability === "undefined") {
		            this._initializeNode(ancestor);
		            candidates.push(ancestor);
		          }
		          if (level === 0)
		            var scoreDivider = 1;
		          else if (level === 1)
		            scoreDivider = 2;
		          else
		            scoreDivider = level * 3;
		          ancestor.readability.contentScore += contentScore / scoreDivider;
		        });
		      });
		      var topCandidates = [];
		      for (var c = 0, cl = candidates.length; c < cl; c += 1) {
		        var candidate = candidates[c];
		        var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
		        candidate.readability.contentScore = candidateScore;
		        this.log("Candidate:", candidate, "with score " + candidateScore);
		        for (var t = 0; t < this._nbTopCandidates; t++) {
		          var aTopCandidate = topCandidates[t];
		          if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
		            topCandidates.splice(t, 0, candidate);
		            if (topCandidates.length > this._nbTopCandidates)
		              topCandidates.pop();
		            break;
		          }
		        }
		      }
		      var topCandidate = topCandidates[0] || null;
		      var neededToCreateTopCandidate = false;
		      var parentOfTopCandidate;
		      if (topCandidate === null || topCandidate.tagName === "BODY") {
		        topCandidate = doc.createElement("DIV");
		        neededToCreateTopCandidate = true;
		        while (page.firstChild) {
		          this.log("Moving child out:", page.firstChild);
		          topCandidate.appendChild(page.firstChild);
		        }
		        page.appendChild(topCandidate);
		        this._initializeNode(topCandidate);
		      } else if (topCandidate) {
		        var alternativeCandidateAncestors = [];
		        for (var i = 1; i < topCandidates.length; i++) {
		          if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
		            alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));
		          }
		        }
		        var MINIMUM_TOPCANDIDATES = 3;
		        if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
		          parentOfTopCandidate = topCandidate.parentNode;
		          while (parentOfTopCandidate.tagName !== "BODY") {
		            var listsContainingThisAncestor = 0;
		            for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
		              listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));
		            }
		            if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
		              topCandidate = parentOfTopCandidate;
		              break;
		            }
		            parentOfTopCandidate = parentOfTopCandidate.parentNode;
		          }
		        }
		        if (!topCandidate.readability) {
		          this._initializeNode(topCandidate);
		        }
		        parentOfTopCandidate = topCandidate.parentNode;
		        var lastScore = topCandidate.readability.contentScore;
		        var scoreThreshold = lastScore / 3;
		        while (parentOfTopCandidate.tagName !== "BODY") {
		          if (!parentOfTopCandidate.readability) {
		            parentOfTopCandidate = parentOfTopCandidate.parentNode;
		            continue;
		          }
		          var parentScore = parentOfTopCandidate.readability.contentScore;
		          if (parentScore < scoreThreshold)
		            break;
		          if (parentScore > lastScore) {
		            topCandidate = parentOfTopCandidate;
		            break;
		          }
		          lastScore = parentOfTopCandidate.readability.contentScore;
		          parentOfTopCandidate = parentOfTopCandidate.parentNode;
		        }
		        parentOfTopCandidate = topCandidate.parentNode;
		        while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
		          topCandidate = parentOfTopCandidate;
		          parentOfTopCandidate = topCandidate.parentNode;
		        }
		        if (!topCandidate.readability) {
		          this._initializeNode(topCandidate);
		        }
		      }
		      var articleContent = doc.createElement("DIV");
		      if (isPaging)
		        articleContent.id = "readability-content";
		      var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);
		      parentOfTopCandidate = topCandidate.parentNode;
		      var siblings = parentOfTopCandidate.children;
		      for (var s = 0, sl = siblings.length; s < sl; s++) {
		        var sibling = siblings[s];
		        var append = false;
		        this.log("Looking at sibling node:", sibling, sibling.readability ? "with score " + sibling.readability.contentScore : "");
		        this.log("Sibling has score", sibling.readability ? sibling.readability.contentScore : "Unknown");
		        if (sibling === topCandidate) {
		          append = true;
		        } else {
		          var contentBonus = 0;
		          if (sibling.className === topCandidate.className && topCandidate.className !== "")
		            contentBonus += topCandidate.readability.contentScore * 0.2;
		          if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
		            append = true;
		          } else if (sibling.nodeName === "P") {
		            var linkDensity = this._getLinkDensity(sibling);
		            var nodeContent = this._getInnerText(sibling);
		            var nodeLength = nodeContent.length;
		            if (nodeLength > 80 && linkDensity < 0.25) {
		              append = true;
		            } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\\.( |$)/) !== -1) {
		              append = true;
		            }
		          }
		        }
		        if (append) {
		          this.log("Appending node:", sibling);
		          if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {
		            this.log("Altering sibling:", sibling, "to div.");
		            sibling = this._setNodeTag(sibling, "DIV");
		          }
		          articleContent.appendChild(sibling);
		          siblings = parentOfTopCandidate.children;
		          s -= 1;
		          sl -= 1;
		        }
		      }
		      if (this._debug)
		        this.log("Article content pre-prep: " + articleContent.innerHTML);
		      this._prepArticle(articleContent);
		      if (this._debug)
		        this.log("Article content post-prep: " + articleContent.innerHTML);
		      if (neededToCreateTopCandidate) {
		        topCandidate.id = "readability-page-1";
		        topCandidate.className = "page";
		      } else {
		        var div = doc.createElement("DIV");
		        div.id = "readability-page-1";
		        div.className = "page";
		        while (articleContent.firstChild) {
		          div.appendChild(articleContent.firstChild);
		        }
		        articleContent.appendChild(div);
		      }
		      if (this._debug)
		        this.log("Article content after paging: " + articleContent.innerHTML);
		      var parseSuccessful = true;
		      var textLength = this._getInnerText(articleContent, true).length;
		      if (textLength < this._charThreshold) {
		        parseSuccessful = false;
		        page.innerHTML = pageCacheHtml;
		        if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
		          this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
		          this._attempts.push({ articleContent, textLength });
		        } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
		          this._removeFlag(this.FLAG_WEIGHT_CLASSES);
		          this._attempts.push({ articleContent, textLength });
		        } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
		          this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
		          this._attempts.push({ articleContent, textLength });
		        } else {
		          this._attempts.push({ articleContent, textLength });
		          this._attempts.sort(function(a, b) {
		            return b.textLength - a.textLength;
		          });
		          if (!this._attempts[0].textLength) {
		            return null;
		          }
		          articleContent = this._attempts[0].articleContent;
		          parseSuccessful = true;
		        }
		      }
		      if (parseSuccessful) {
		        var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));
		        this._someNode(ancestors, function(ancestor) {
		          if (!ancestor.tagName)
		            return false;
		          var articleDir = ancestor.getAttribute("dir");
		          if (articleDir) {
		            this._articleDir = articleDir;
		            return true;
		          }
		          return false;
		        });
		        return articleContent;
		      }
		    }
		  }, "_grabArticle"),
		  /**
		   * Check whether the input string could be a byline.
		   * This verifies that the input is a string, and that the length
		   * is less than 100 chars.
		   *
		   * @param possibleByline {string} - a string to check whether its a byline.
		   * @return Boolean - whether the input string is a byline.
		   */
		  _isValidByline: /* @__PURE__ */ __name(function(byline) {
		    if (typeof byline == "string" || byline instanceof String) {
		      byline = byline.trim();
		      return byline.length > 0 && byline.length < 100;
		    }
		    return false;
		  }, "_isValidByline"),
		  /**
		   * Converts some of the common HTML entities in string to their corresponding characters.
		   *
		   * @param str {string} - a string to unescape.
		   * @return string without HTML entity.
		   */
		  _unescapeHtmlEntities: /* @__PURE__ */ __name(function(str) {
		    if (!str) {
		      return str;
		    }
		    var htmlEscapeMap = this.HTML_ESCAPE_MAP;
		    return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {
		      return htmlEscapeMap[tag];
		    }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_, hex, numStr) {
		      var num = parseInt(hex || numStr, hex ? 16 : 10);
		      return String.fromCharCode(num);
		    });
		  }, "_unescapeHtmlEntities"),
		  /**
		   * Try to extract metadata from JSON-LD object.
		   * For now, only Schema.org objects of type Article or its subtypes are supported.
		   * @return Object with any metadata that could be extracted (possibly none)
		   */
		  _getJSONLD: /* @__PURE__ */ __name(function(doc) {
		    var scripts = this._getAllNodesWithTag(doc, ["script"]);
		    var metadata;
		    this._forEachNode(scripts, function(jsonLdElement) {
		      if (!metadata && jsonLdElement.getAttribute("type") === "application/ld+json") {
		        try {
		          var content = jsonLdElement.textContent.replace(/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g, "");
		          var parsed = JSON.parse(content);
		          if (!parsed["@context"] || !parsed["@context"].match(/^https?\\:\\/\\/schema\\.org$/)) {
		            return;
		          }
		          if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
		            parsed = parsed["@graph"].find(function(it) {
		              return (it["@type"] || "").match(
		                this.REGEXPS.jsonLdArticleTypes
		              );
		            });
		          }
		          if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
		            return;
		          }
		          metadata = {};
		          if (typeof parsed.name === "string" && typeof parsed.headline === "string" && parsed.name !== parsed.headline) {
		            var title = this._getArticleTitle();
		            var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;
		            var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;
		            if (headlineMatches && !nameMatches) {
		              metadata.title = parsed.headline;
		            } else {
		              metadata.title = parsed.name;
		            }
		          } else if (typeof parsed.name === "string") {
		            metadata.title = parsed.name.trim();
		          } else if (typeof parsed.headline === "string") {
		            metadata.title = parsed.headline.trim();
		          }
		          if (parsed.author) {
		            if (typeof parsed.author.name === "string") {
		              metadata.byline = parsed.author.name.trim();
		            } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
		              metadata.byline = parsed.author.filter(function(author) {
		                return author && typeof author.name === "string";
		              }).map(function(author) {
		                return author.name.trim();
		              }).join(", ");
		            }
		          }
		          if (typeof parsed.description === "string") {
		            metadata.excerpt = parsed.description.trim();
		          }
		          if (parsed.publisher && typeof parsed.publisher.name === "string") {
		            metadata.siteName = parsed.publisher.name.trim();
		          }
		          if (typeof parsed.datePublished === "string") {
		            metadata.datePublished = parsed.datePublished.trim();
		          }
		          return;
		        } catch (err) {
		          this.log(err.message);
		        }
		      }
		    });
		    return metadata ? metadata : {};
		  }, "_getJSONLD"),
		  /**
		   * Attempts to get excerpt and byline metadata for the article.
		   *
		   * @param {Object} jsonld — object containing any metadata that
		   * could be extracted from JSON-LD object.
		   *
		   * @return Object with optional "excerpt" and "byline" properties
		   */
		  _getArticleMetadata: /* @__PURE__ */ __name(function(jsonld) {
		    var metadata = {};
		    var values = {};
		    var metaElements = this._doc.getElementsByTagName("meta");
		    var propertyPattern = /\\s*(article|dc|dcterm|og|twitter)\\s*:\\s*(author|creator|description|published_time|title|site_name)\\s*/gi;
		    var namePattern = /^\\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\\s*[\\.:]\\s*)?(author|creator|description|title|site_name)\\s*$/i;
		    this._forEachNode(metaElements, function(element) {
		      var elementName = element.getAttribute("name");
		      var elementProperty = element.getAttribute("property");
		      var content = element.getAttribute("content");
		      if (!content) {
		        return;
		      }
		      var matches = null;
		      var name = null;
		      if (elementProperty) {
		        matches = elementProperty.match(propertyPattern);
		        if (matches) {
		          name = matches[0].toLowerCase().replace(/\\s/g, "");
		          values[name] = content.trim();
		        }
		      }
		      if (!matches && elementName && namePattern.test(elementName)) {
		        name = elementName;
		        if (content) {
		          name = name.toLowerCase().replace(/\\s/g, "").replace(/\\./g, ":");
		          values[name] = content.trim();
		        }
		      }
		    });
		    metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values["title"] || values["twitter:title"];
		    if (!metadata.title) {
		      metadata.title = this._getArticleTitle();
		    }
		    metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values["author"];
		    metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values["description"] || values["twitter:description"];
		    metadata.siteName = jsonld.siteName || values["og:site_name"];
		    metadata.publishedTime = jsonld.datePublished || values["article:published_time"] || null;
		    metadata.title = this._unescapeHtmlEntities(metadata.title);
		    metadata.byline = this._unescapeHtmlEntities(metadata.byline);
		    metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
		    metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
		    metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);
		    return metadata;
		  }, "_getArticleMetadata"),
		  /**
		   * Check if node is image, or if node contains exactly only one image
		   * whether as a direct child or as its descendants.
		   *
		   * @param Element
		  **/
		  _isSingleImage: /* @__PURE__ */ __name(function(node) {
		    if (node.tagName === "IMG") {
		      return true;
		    }
		    if (node.children.length !== 1 || node.textContent.trim() !== "") {
		      return false;
		    }
		    return this._isSingleImage(node.children[0]);
		  }, "_isSingleImage"),
		  /**
		   * Find all <noscript> that are located after <img> nodes, and which contain only one
		   * <img> element. Replace the first image with the image from inside the <noscript> tag,
		   * and remove the <noscript> tag. This improves the quality of the images we use on
		   * some sites (e.g. Medium).
		   *
		   * @param Element
		  **/
		  _unwrapNoscriptImages: /* @__PURE__ */ __name(function(doc) {
		    var imgs = Array.from(doc.getElementsByTagName("img"));
		    this._forEachNode(imgs, function(img) {
		      for (var i = 0; i < img.attributes.length; i++) {
		        var attr = img.attributes[i];
		        switch (attr.name) {
		          case "src":
		          case "srcset":
		          case "data-src":
		          case "data-srcset":
		            return;
		        }
		        if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
		          return;
		        }
		      }
		      img.parentNode.removeChild(img);
		    });
		    var noscripts = Array.from(doc.getElementsByTagName("noscript"));
		    this._forEachNode(noscripts, function(noscript) {
		      var tmp = doc.createElement("div");
		      tmp.innerHTML = noscript.innerHTML;
		      if (!this._isSingleImage(tmp)) {
		        return;
		      }
		      var prevElement = noscript.previousElementSibling;
		      if (prevElement && this._isSingleImage(prevElement)) {
		        var prevImg = prevElement;
		        if (prevImg.tagName !== "IMG") {
		          prevImg = prevElement.getElementsByTagName("img")[0];
		        }
		        var newImg = tmp.getElementsByTagName("img")[0];
		        for (var i = 0; i < prevImg.attributes.length; i++) {
		          var attr = prevImg.attributes[i];
		          if (attr.value === "") {
		            continue;
		          }
		          if (attr.name === "src" || attr.name === "srcset" || /\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
		            if (newImg.getAttribute(attr.name) === attr.value) {
		              continue;
		            }
		            var attrName = attr.name;
		            if (newImg.hasAttribute(attrName)) {
		              attrName = "data-old-" + attrName;
		            }
		            newImg.setAttribute(attrName, attr.value);
		          }
		        }
		        noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
		      }
		    });
		  }, "_unwrapNoscriptImages"),
		  /**
		   * Removes script tags from the document.
		   *
		   * @param Element
		  **/
		  _removeScripts: /* @__PURE__ */ __name(function(doc) {
		    this._removeNodes(this._getAllNodesWithTag(doc, ["script", "noscript"]));
		  }, "_removeScripts"),
		  /**
		   * Check if this node has only whitespace and a single element with given tag
		   * Returns false if the DIV node contains non-empty text nodes
		   * or if it contains no element with given tag or more than 1 element.
		   *
		   * @param Element
		   * @param string tag of child element
		  **/
		  _hasSingleTagInsideElement: /* @__PURE__ */ __name(function(element, tag) {
		    if (element.children.length != 1 || element.children[0].tagName !== tag) {
		      return false;
		    }
		    return !this._someNode(element.childNodes, function(node) {
		      return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
		    });
		  }, "_hasSingleTagInsideElement"),
		  _isElementWithoutContent: /* @__PURE__ */ __name(function(node) {
		    return node.nodeType === this.ELEMENT_NODE && node.textContent.trim().length == 0 && (node.children.length == 0 || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
		  }, "_isElementWithoutContent"),
		  /**
		   * Determine whether element has any children block level elements.
		   *
		   * @param Element
		   */
		  _hasChildBlockElement: /* @__PURE__ */ __name(function(element) {
		    return this._someNode(element.childNodes, function(node) {
		      return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
		    });
		  }, "_hasChildBlockElement"),
		  /***
		   * Determine if a node qualifies as phrasing content.
		   * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
		  **/
		  _isPhrasingContent: /* @__PURE__ */ __name(function(node) {
		    return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
		  }, "_isPhrasingContent"),
		  _isWhitespace: /* @__PURE__ */ __name(function(node) {
		    return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
		  }, "_isWhitespace"),
		  /**
		   * Get the inner text of a node - cross browser compatibly.
		   * This also strips out any excess whitespace to be found.
		   *
		   * @param Element
		   * @param Boolean normalizeSpaces (default: true)
		   * @return string
		  **/
		  _getInnerText: /* @__PURE__ */ __name(function(e, normalizeSpaces) {
		    normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
		    var textContent = e.textContent.trim();
		    if (normalizeSpaces) {
		      return textContent.replace(this.REGEXPS.normalize, " ");
		    }
		    return textContent;
		  }, "_getInnerText"),
		  /**
		   * Get the number of times a string s appears in the node e.
		   *
		   * @param Element
		   * @param string - what to split on. Default is ","
		   * @return number (integer)
		  **/
		  _getCharCount: /* @__PURE__ */ __name(function(e, s) {
		    s = s || ",";
		    return this._getInnerText(e).split(s).length - 1;
		  }, "_getCharCount"),
		  /**
		   * Remove the style attribute on every e and under.
		   * TODO: Test if getElementsByTagName(*) is faster.
		   *
		   * @param Element
		   * @return void
		  **/
		  _cleanStyles: /* @__PURE__ */ __name(function(e) {
		    if (!e || e.tagName.toLowerCase() === "svg")
		      return;
		    for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {
		      e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);
		    }
		    if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {
		      e.removeAttribute("width");
		      e.removeAttribute("height");
		    }
		    var cur = e.firstElementChild;
		    while (cur !== null) {
		      this._cleanStyles(cur);
		      cur = cur.nextElementSibling;
		    }
		  }, "_cleanStyles"),
		  /**
		   * Get the density of links as a percentage of the content
		   * This is the amount of text that is inside a link divided by the total text in the node.
		   *
		   * @param Element
		   * @return number (float)
		  **/
		  _getLinkDensity: /* @__PURE__ */ __name(function(element) {
		    var textLength = this._getInnerText(element).length;
		    if (textLength === 0)
		      return 0;
		    var linkLength = 0;
		    this._forEachNode(element.getElementsByTagName("a"), function(linkNode) {
		      var href = linkNode.getAttribute("href");
		      var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
		      linkLength += this._getInnerText(linkNode).length * coefficient;
		    });
		    return linkLength / textLength;
		  }, "_getLinkDensity"),
		  /**
		   * Get an elements class/id weight. Uses regular expressions to tell if this
		   * element looks good or bad.
		   *
		   * @param Element
		   * @return number (Integer)
		  **/
		  _getClassWeight: /* @__PURE__ */ __name(function(e) {
		    if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))
		      return 0;
		    var weight = 0;
		    if (typeof e.className === "string" && e.className !== "") {
		      if (this.REGEXPS.negative.test(e.className))
		        weight -= 25;
		      if (this.REGEXPS.positive.test(e.className))
		        weight += 25;
		    }
		    if (typeof e.id === "string" && e.id !== "") {
		      if (this.REGEXPS.negative.test(e.id))
		        weight -= 25;
		      if (this.REGEXPS.positive.test(e.id))
		        weight += 25;
		    }
		    return weight;
		  }, "_getClassWeight"),
		  /**
		   * Clean a node of all elements of type "tag".
		   * (Unless it's a youtube/vimeo video. People love movies.)
		   *
		   * @param Element
		   * @param string tag to clean
		   * @return void
		   **/
		  _clean: /* @__PURE__ */ __name(function(e, tag) {
		    var isEmbed = ["object", "embed", "iframe"].indexOf(tag) !== -1;
		    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element) {
		      if (isEmbed) {
		        for (var i = 0; i < element.attributes.length; i++) {
		          if (this._allowedVideoRegex.test(element.attributes[i].value)) {
		            return false;
		          }
		        }
		        if (element.tagName === "object" && this._allowedVideoRegex.test(element.innerHTML)) {
		          return false;
		        }
		      }
		      return true;
		    });
		  }, "_clean"),
		  /**
		   * Check if a given node has one of its ancestor tag name matching the
		   * provided one.
		   * @param  HTMLElement node
		   * @param  String      tagName
		   * @param  Number      maxDepth
		   * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
		   * @return Boolean
		   */
		  _hasAncestorTag: /* @__PURE__ */ __name(function(node, tagName, maxDepth, filterFn) {
		    maxDepth = maxDepth || 3;
		    tagName = tagName.toUpperCase();
		    var depth = 0;
		    while (node.parentNode) {
		      if (maxDepth > 0 && depth > maxDepth)
		        return false;
		      if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))
		        return true;
		      node = node.parentNode;
		      depth++;
		    }
		    return false;
		  }, "_hasAncestorTag"),
		  /**
		   * Return an object indicating how many rows and columns this table has.
		   */
		  _getRowAndColumnCount: /* @__PURE__ */ __name(function(table) {
		    var rows = 0;
		    var columns = 0;
		    var trs = table.getElementsByTagName("tr");
		    for (var i = 0; i < trs.length; i++) {
		      var rowspan = trs[i].getAttribute("rowspan") || 0;
		      if (rowspan) {
		        rowspan = parseInt(rowspan, 10);
		      }
		      rows += rowspan || 1;
		      var columnsInThisRow = 0;
		      var cells = trs[i].getElementsByTagName("td");
		      for (var j = 0; j < cells.length; j++) {
		        var colspan = cells[j].getAttribute("colspan") || 0;
		        if (colspan) {
		          colspan = parseInt(colspan, 10);
		        }
		        columnsInThisRow += colspan || 1;
		      }
		      columns = Math.max(columns, columnsInThisRow);
		    }
		    return { rows, columns };
		  }, "_getRowAndColumnCount"),
		  /**
		   * Look for 'data' (as opposed to 'layout') tables, for which we use
		   * similar checks as
		   * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19
		   */
		  _markDataTables: /* @__PURE__ */ __name(function(root) {
		    var tables = root.getElementsByTagName("table");
		    for (var i = 0; i < tables.length; i++) {
		      var table = tables[i];
		      var role = table.getAttribute("role");
		      if (role == "presentation") {
		        table._readabilityDataTable = false;
		        continue;
		      }
		      var datatable = table.getAttribute("datatable");
		      if (datatable == "0") {
		        table._readabilityDataTable = false;
		        continue;
		      }
		      var summary = table.getAttribute("summary");
		      if (summary) {
		        table._readabilityDataTable = true;
		        continue;
		      }
		      var caption = table.getElementsByTagName("caption")[0];
		      if (caption && caption.childNodes.length > 0) {
		        table._readabilityDataTable = true;
		        continue;
		      }
		      var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
		      var descendantExists = /* @__PURE__ */ __name(function(tag) {
		        return !!table.getElementsByTagName(tag)[0];
		      }, "descendantExists");
		      if (dataTableDescendants.some(descendantExists)) {
		        this.log("Data table because found data-y descendant");
		        table._readabilityDataTable = true;
		        continue;
		      }
		      if (table.getElementsByTagName("table")[0]) {
		        table._readabilityDataTable = false;
		        continue;
		      }
		      var sizeInfo = this._getRowAndColumnCount(table);
		      if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
		        table._readabilityDataTable = true;
		        continue;
		      }
		      table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
		    }
		  }, "_markDataTables"),
		  /* convert images and figures that have properties like data-src into images that can be loaded without JS */
		  _fixLazyImages: /* @__PURE__ */ __name(function(root) {
		    this._forEachNode(this._getAllNodesWithTag(root, ["img", "picture", "figure"]), function(elem) {
		      if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
		        var parts = this.REGEXPS.b64DataUrl.exec(elem.src);
		        if (parts[1] === "image/svg+xml") {
		          return;
		        }
		        var srcCouldBeRemoved = false;
		        for (var i = 0; i < elem.attributes.length; i++) {
		          var attr = elem.attributes[i];
		          if (attr.name === "src") {
		            continue;
		          }
		          if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
		            srcCouldBeRemoved = true;
		            break;
		          }
		        }
		        if (srcCouldBeRemoved) {
		          var b64starts = elem.src.search(/base64\\s*/i) + 7;
		          var b64length = elem.src.length - b64starts;
		          if (b64length < 133) {
		            elem.removeAttribute("src");
		          }
		        }
		      }
		      if ((elem.src || elem.srcset && elem.srcset != "null") && elem.className.toLowerCase().indexOf("lazy") === -1) {
		        return;
		      }
		      for (var j = 0; j < elem.attributes.length; j++) {
		        attr = elem.attributes[j];
		        if (attr.name === "src" || attr.name === "srcset" || attr.name === "alt") {
		          continue;
		        }
		        var copyTo = null;
		        if (/\\.(jpg|jpeg|png|webp)\\s+\\d/.test(attr.value)) {
		          copyTo = "srcset";
		        } else if (/^\\s*\\S+\\.(jpg|jpeg|png|webp)\\S*\\s*$/.test(attr.value)) {
		          copyTo = "src";
		        }
		        if (copyTo) {
		          if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
		            elem.setAttribute(copyTo, attr.value);
		          } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
		            var img = this._doc.createElement("img");
		            img.setAttribute(copyTo, attr.value);
		            elem.appendChild(img);
		          }
		        }
		      }
		    });
		  }, "_fixLazyImages"),
		  _getTextDensity: /* @__PURE__ */ __name(function(e, tags) {
		    var textLength = this._getInnerText(e, true).length;
		    if (textLength === 0) {
		      return 0;
		    }
		    var childrenLength = 0;
		    var children = this._getAllNodesWithTag(e, tags);
		    this._forEachNode(children, (child) => childrenLength += this._getInnerText(child, true).length);
		    return childrenLength / textLength;
		  }, "_getTextDensity"),
		  /**
		   * Clean an element of all tags of type "tag" if they look fishy.
		   * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
		   *
		   * @return void
		   **/
		  _cleanConditionally: /* @__PURE__ */ __name(function(e, tag) {
		    if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))
		      return;
		    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {
		      var isDataTable = /* @__PURE__ */ __name(function(t) {
		        return t._readabilityDataTable;
		      }, "isDataTable");
		      var isList = tag === "ul" || tag === "ol";
		      if (!isList) {
		        var listLength = 0;
		        var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);
		        this._forEachNode(listNodes, (list) => listLength += this._getInnerText(list).length);
		        isList = listLength / this._getInnerText(node).length > 0.9;
		      }
		      if (tag === "table" && isDataTable(node)) {
		        return false;
		      }
		      if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
		        return false;
		      }
		      if (this._hasAncestorTag(node, "code")) {
		        return false;
		      }
		      var weight = this._getClassWeight(node);
		      this.log("Cleaning Conditionally", node);
		      var contentScore = 0;
		      if (weight + contentScore < 0) {
		        return true;
		      }
		      if (this._getCharCount(node, ",") < 10) {
		        var p = node.getElementsByTagName("p").length;
		        var img = node.getElementsByTagName("img").length;
		        var li = node.getElementsByTagName("li").length - 100;
		        var input = node.getElementsByTagName("input").length;
		        var headingDensity = this._getTextDensity(node, ["h1", "h2", "h3", "h4", "h5", "h6"]);
		        var embedCount = 0;
		        var embeds = this._getAllNodesWithTag(node, ["object", "embed", "iframe"]);
		        for (var i = 0; i < embeds.length; i++) {
		          for (var j = 0; j < embeds[i].attributes.length; j++) {
		            if (this._allowedVideoRegex.test(embeds[i].attributes[j].value)) {
		              return false;
		            }
		          }
		          if (embeds[i].tagName === "object" && this._allowedVideoRegex.test(embeds[i].innerHTML)) {
		            return false;
		          }
		          embedCount++;
		        }
		        var linkDensity = this._getLinkDensity(node);
		        var contentLength = this._getInnerText(node).length;
		        var haveToRemove = img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, "figure") || !isList && li > p || input > Math.floor(p / 3) || !isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, "figure") || !isList && weight < 25 && linkDensity > 0.2 || weight >= 25 && linkDensity > 0.5 || (embedCount === 1 && contentLength < 75 || embedCount > 1);
		        if (isList && haveToRemove) {
		          for (var x = 0; x < node.children.length; x++) {
		            let child = node.children[x];
		            if (child.children.length > 1) {
		              return haveToRemove;
		            }
		          }
		          let li_count = node.getElementsByTagName("li").length;
		          if (img == li_count) {
		            return false;
		          }
		        }
		        return haveToRemove;
		      }
		      return false;
		    });
		  }, "_cleanConditionally"),
		  /**
		   * Clean out elements that match the specified conditions
		   *
		   * @param Element
		   * @param Function determines whether a node should be removed
		   * @return void
		   **/
		  _cleanMatchedNodes: /* @__PURE__ */ __name(function(e, filter) {
		    var endOfSearchMarkerNode = this._getNextNode(e, true);
		    var next = this._getNextNode(e);
		    while (next && next != endOfSearchMarkerNode) {
		      if (filter.call(this, next, next.className + " " + next.id)) {
		        next = this._removeAndGetNext(next);
		      } else {
		        next = this._getNextNode(next);
		      }
		    }
		  }, "_cleanMatchedNodes"),
		  /**
		   * Clean out spurious headers from an Element.
		   *
		   * @param Element
		   * @return void
		  **/
		  _cleanHeaders: /* @__PURE__ */ __name(function(e) {
		    let headingNodes = this._getAllNodesWithTag(e, ["h1", "h2"]);
		    this._removeNodes(headingNodes, function(node) {
		      let shouldRemove = this._getClassWeight(node) < 0;
		      if (shouldRemove) {
		        this.log("Removing header with low class weight:", node);
		      }
		      return shouldRemove;
		    });
		  }, "_cleanHeaders"),
		  /**
		   * Check if this node is an H1 or H2 element whose content is mostly
		   * the same as the article title.
		   *
		   * @param Element  the node to check.
		   * @return boolean indicating whether this is a title-like header.
		   */
		  _headerDuplicatesTitle: /* @__PURE__ */ __name(function(node) {
		    if (node.tagName != "H1" && node.tagName != "H2") {
		      return false;
		    }
		    var heading = this._getInnerText(node, false);
		    this.log("Evaluating similarity of header:", heading, this._articleTitle);
		    return this._textSimilarity(this._articleTitle, heading) > 0.75;
		  }, "_headerDuplicatesTitle"),
		  _flagIsActive: /* @__PURE__ */ __name(function(flag) {
		    return (this._flags & flag) > 0;
		  }, "_flagIsActive"),
		  _removeFlag: /* @__PURE__ */ __name(function(flag) {
		    this._flags = this._flags & ~flag;
		  }, "_removeFlag"),
		  _isProbablyVisible: /* @__PURE__ */ __name(function(node) {
		    return (!node.style || node.style.display != "none") && (!node.style || node.style.visibility != "hidden") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
		  }, "_isProbablyVisible"),
		  /**
		   * Runs readability.
		   *
		   * Workflow:
		   *  1. Prep the document by removing script tags, css, etc.
		   *  2. Build readability's DOM tree.
		   *  3. Grab the article content from the current dom tree.
		   *  4. Replace the current DOM tree with the new one.
		   *  5. Read peacefully.
		   *
		   * @return void
		   **/
		  parse: /* @__PURE__ */ __name(function() {
		    if (this._maxElemsToParse > 0) {
		      var numTags = this._doc.getElementsByTagName("*").length;
		      if (numTags > this._maxElemsToParse) {
		        throw new Error("Aborting parsing document; " + numTags + " elements found");
		      }
		    }
		    this._unwrapNoscriptImages(this._doc);
		    var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);
		    this._removeScripts(this._doc);
		    this._prepDocument();
		    var metadata = this._getArticleMetadata(jsonLd);
		    this._articleTitle = metadata.title;
		    var articleContent = this._grabArticle();
		    if (!articleContent)
		      return null;
		    this.log("Grabbed: " + articleContent.innerHTML);
		    this._postProcessContent(articleContent);
		    if (!metadata.excerpt) {
		      var paragraphs = articleContent.getElementsByTagName("p");
		      if (paragraphs.length > 0) {
		        metadata.excerpt = paragraphs[0].textContent.trim();
		      }
		    }
		    var textContent = articleContent.textContent;
		    return {
		      title: this._articleTitle,
		      byline: metadata.byline || this._articleByline,
		      dir: this._articleDir,
		      lang: this._articleLang,
		      content: this._serializer(articleContent),
		      textContent,
		      length: textContent.length,
		      excerpt: metadata.excerpt,
		      siteName: metadata.siteName || this._articleSiteName,
		      publishedTime: metadata.publishedTime
		    };
		  }, "parse")
		};
		{
		  module.exports = Readability;
		} 
	} (Readability));
	return Readability.exports;
}

var ReadabilityReaderable = {exports: {}};

var hasRequiredReadabilityReaderable;

function requireReadabilityReaderable () {
	if (hasRequiredReadabilityReaderable) return ReadabilityReaderable.exports;
	hasRequiredReadabilityReaderable = 1;
	(function (module) {
		var __defProp = Object.defineProperty;
		var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
		var REGEXPS = {
		  // NOTE: These two regular expressions are duplicated in
		  // Readability.js. Please keep both copies in sync.
		  unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
		  okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
		};
		function isNodeVisible(node) {
		  return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
		}
		__name(isNodeVisible, "isNodeVisible");
		function isProbablyReaderable(doc, options = {}) {
		  if (typeof options == "function") {
		    options = { visibilityChecker: options };
		  }
		  var defaultOptions = { minScore: 20, minContentLength: 140, visibilityChecker: isNodeVisible };
		  options = Object.assign(defaultOptions, options);
		  var nodes = doc.querySelectorAll("p, pre, article");
		  var brNodes = doc.querySelectorAll("div > br");
		  if (brNodes.length) {
		    var set = new Set(nodes);
		    [].forEach.call(brNodes, function(node) {
		      set.add(node.parentNode);
		    });
		    nodes = Array.from(set);
		  }
		  var score = 0;
		  return [].some.call(nodes, function(node) {
		    if (!options.visibilityChecker(node)) {
		      return false;
		    }
		    var matchString = node.className + " " + node.id;
		    if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
		      return false;
		    }
		    if (node.matches("li p")) {
		      return false;
		    }
		    var textContentLength = node.textContent.trim().length;
		    if (textContentLength < options.minContentLength) {
		      return false;
		    }
		    score += Math.sqrt(textContentLength - options.minContentLength);
		    if (score > options.minScore) {
		      return true;
		    }
		    return false;
		  });
		}
		__name(isProbablyReaderable, "isProbablyReaderable");
		{
		  module.exports = isProbablyReaderable;
		} 
	} (ReadabilityReaderable));
	return ReadabilityReaderable.exports;
}

var readability;
var hasRequiredReadability;

function requireReadability () {
	if (hasRequiredReadability) return readability;
	hasRequiredReadability = 1;
	var Readability = requireReadability$1();
	var isProbablyReaderable = requireReadabilityReaderable();
	readability = {
	  Readability,
	  isProbablyReaderable
	};
	return readability;
}

var readabilityExports = requireReadability();

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	var __defProp = Object.defineProperty;
	var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
	let p = process || {};
	let argv = p.argv || [];
	let env = p.env || {};
	let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
	let formatter = /* @__PURE__ */ __name((open, close, replace = open) => (input) => {
	  let string = "" + input, index = string.indexOf(close, open.length);
	  return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	}, "formatter");
	let replaceClose = /* @__PURE__ */ __name((string, close, replace, index) => {
	  let result = "", cursor = 0;
	  do {
	    result += string.substring(cursor, index) + replace;
	    cursor = index + close.length;
	    index = string.indexOf(close, cursor);
	  } while (~index);
	  return result + string.substring(cursor);
	}, "replaceClose");
	let createColors = /* @__PURE__ */ __name((enabled = isColorSupported) => {
	  let f = enabled ? formatter : () => String;
	  return {
	    isColorSupported: enabled,
	    reset: f("\\x1B[0m", "\\x1B[0m"),
	    bold: f("\\x1B[1m", "\\x1B[22m", "\\x1B[22m\\x1B[1m"),
	    dim: f("\\x1B[2m", "\\x1B[22m", "\\x1B[22m\\x1B[2m"),
	    italic: f("\\x1B[3m", "\\x1B[23m"),
	    underline: f("\\x1B[4m", "\\x1B[24m"),
	    inverse: f("\\x1B[7m", "\\x1B[27m"),
	    hidden: f("\\x1B[8m", "\\x1B[28m"),
	    strikethrough: f("\\x1B[9m", "\\x1B[29m"),
	    black: f("\\x1B[30m", "\\x1B[39m"),
	    red: f("\\x1B[31m", "\\x1B[39m"),
	    green: f("\\x1B[32m", "\\x1B[39m"),
	    yellow: f("\\x1B[33m", "\\x1B[39m"),
	    blue: f("\\x1B[34m", "\\x1B[39m"),
	    magenta: f("\\x1B[35m", "\\x1B[39m"),
	    cyan: f("\\x1B[36m", "\\x1B[39m"),
	    white: f("\\x1B[37m", "\\x1B[39m"),
	    gray: f("\\x1B[90m", "\\x1B[39m"),
	    bgBlack: f("\\x1B[40m", "\\x1B[49m"),
	    bgRed: f("\\x1B[41m", "\\x1B[49m"),
	    bgGreen: f("\\x1B[42m", "\\x1B[49m"),
	    bgYellow: f("\\x1B[43m", "\\x1B[49m"),
	    bgBlue: f("\\x1B[44m", "\\x1B[49m"),
	    bgMagenta: f("\\x1B[45m", "\\x1B[49m"),
	    bgCyan: f("\\x1B[46m", "\\x1B[49m"),
	    bgWhite: f("\\x1B[47m", "\\x1B[49m"),
	    blackBright: f("\\x1B[90m", "\\x1B[39m"),
	    redBright: f("\\x1B[91m", "\\x1B[39m"),
	    greenBright: f("\\x1B[92m", "\\x1B[39m"),
	    yellowBright: f("\\x1B[93m", "\\x1B[39m"),
	    blueBright: f("\\x1B[94m", "\\x1B[39m"),
	    magentaBright: f("\\x1B[95m", "\\x1B[39m"),
	    cyanBright: f("\\x1B[96m", "\\x1B[39m"),
	    whiteBright: f("\\x1B[97m", "\\x1B[39m"),
	    bgBlackBright: f("\\x1B[100m", "\\x1B[49m"),
	    bgRedBright: f("\\x1B[101m", "\\x1B[49m"),
	    bgGreenBright: f("\\x1B[102m", "\\x1B[49m"),
	    bgYellowBright: f("\\x1B[103m", "\\x1B[49m"),
	    bgBlueBright: f("\\x1B[104m", "\\x1B[49m"),
	    bgMagentaBright: f("\\x1B[105m", "\\x1B[49m"),
	    bgCyanBright: f("\\x1B[106m", "\\x1B[49m"),
	    bgWhiteBright: f("\\x1B[107m", "\\x1B[49m")
	  };
	}, "createColors");
	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var picocolorsExports = /*@__PURE__*/ requirePicocolors();
const c = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

var __defProp$3 = Object.defineProperty;
var __name$3 = (target, value) => __defProp$3(target, "name", { value, configurable: true });
const turndown = new Turndown();
turndown.use(gfm);
function toMarkdown(html) {
  return turndown.turndown(html);
}
__name$3(toMarkdown, "toMarkdown");

var __defProp$2 = Object.defineProperty;
var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
class Logger {
  static {
    __name$2(this, "Logger");
  }
  level;
  setLevel(level) {
    this.level = level;
  }
  info(...args) {
    if (this.level === "silent") return;
    console.log(c.cyan("INFO"), ...args);
  }
  warn(...args) {
    if (this.level === "silent") return;
    console.warn(c.yellow("WARN"), ...args);
  }
}
const logger = new Logger();

var __defProp$1 = Object.defineProperty;
var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
function formatNumber(num) {
  return num > 1e6 ? \`\${(num / 1e6).toFixed(1)}M\` : num > 1e3 ? \`\${(num / 1e3).toFixed(1)}K\` : num.toString();
}
__name$1(formatNumber, "formatNumber");
function matchPath(path, pattern) {
  return micromatch.isMatch(path, pattern);
}
__name$1(matchPath, "matchPath");
function ensureArray(input) {
  return Array.isArray(input) ? input : [input];
}
__name$1(ensureArray, "ensureArray");

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
async function fetchSite(url, options) {
  const fetcher = new Fetcher(options);
  return fetcher.fetchSite(url);
}
__name(fetchSite, "fetchSite");
class Fetcher {
  constructor(options) {
    this.options = options;
    const concurrency = options.concurrency || 3;
    this.#queue = new PQueue({ concurrency });
  }
  static {
    __name(this, "Fetcher");
  }
  #pages = /* @__PURE__ */ new Map();
  #fetched = /* @__PURE__ */ new Set();
  #queue;
  #limitReached() {
    return this.options.limit && this.#pages.size >= this.options.limit;
  }
  #getContentSelector(pathname) {
    if (typeof this.options.contentSelector === "function")
      return this.options.contentSelector({ pathname });
    return this.options.contentSelector;
  }
  async fetchSite(url) {
    logger.info(
      \`Started fetching \${c.green(url)} with a concurrency of \${this.#queue.concurrency}\`
    );
    await this.#fetchPage(url, {
      skipMatch: true
    });
    await this.#queue.onIdle();
    return this.#pages;
  }
  async #fetchPage(url, options) {
    const { host, pathname } = new URL(url);
    if (this.#fetched.has(pathname) || this.#limitReached()) {
      return;
    }
    this.#fetched.add(pathname);
    if (!options.skipMatch && this.options.match && !matchPath(pathname, this.options.match)) {
      return;
    }
    logger.info(\`Fetching \${c.green(url)}\`);
    const res = await (this.options.fetch || fetch)(url, {
      headers: {
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
      }
    });
    if (!res.ok) {
      logger.warn(\`Failed to fetch \${url}: \${res.statusText}\`);
      return;
    }
    if (this.#limitReached()) {
      return;
    }
    const contentType = res.headers.get("content-type");
    if (!contentType?.includes("text/html")) {
      logger.warn(\`Not a HTML page: \${url}\`);
      return;
    }
    const resUrl = new URL(res.url);
    if (resUrl.host !== host) {
      logger.warn(\`Redirected from \${host} to \${resUrl.host}\`);
      return;
    }
    const extraUrls = [];
    const $ = load(await res.text());
    $("script,style,link,img,video").remove();
    $("a").each((_, el) => {
      const href = $(el).attr("href");
      if (!href) {
        return;
      }
      const thisUrl = new URL(href, url);
      if (thisUrl.host !== host) {
        return;
      }
      extraUrls.push(thisUrl.href);
    });
    if (extraUrls.length > 0) {
      for (const url2 of extraUrls) {
        this.#queue.add(
          () => this.#fetchPage(url2, { ...options, skipMatch: false })
        );
      }
    }
    const window = new Window({
      url,
      settings: {
        disableJavaScriptFileLoading: true,
        disableJavaScriptEvaluation: true,
        disableCSSFileLoading: true
      }
    });
    const pageTitle = $("title").text();
    const contentSelector = this.#getContentSelector(pathname);
    const html = contentSelector ? $(contentSelector).prop("outerHTML") : $.html();
    if (!html) {
      logger.warn(\`No readable content on \${pathname}\`);
      return;
    }
    window.document.write(html);
    await window.happyDOM.waitUntilComplete();
    const article = new readabilityExports.Readability(window.document).parse();
    await window.happyDOM.close();
    if (!article) {
      return;
    }
    const content = toMarkdown(article.content);
    this.#pages.set(pathname, {
      title: article.title || pageTitle,
      url,
      content
    });
  }
}
function serializePages(pages, format) {
  if (format === "json") {
    return JSON.stringify([...pages.values()]);
  }
  return [...pages.values()].map(
    (page) => \`<page>
  <title>\${page.title}</title>
  <url>\${page.url}</url>
  <content>\${page.content}</content>
</page>\`.trim()
  ).join("\\n\\n");
}
__name(serializePages, "serializePages");

export { formatNumber as a, ensureArray as e, fetchSite as f, logger as l, serializePages as s };
",
]
`;

exports[`packem ecosystem > should work with provided 'sitefetch' ecosystem suite and oxc resolver 1`] = `
[
  "export {};
",
  "#!/usr/bin/env node
import path from 'node:path';
import fs from 'node:fs';
import { EventEmitter } from 'events';
import { encode } from 'gpt-tokenizer/model/gpt-4o';
import { l as logger, f as fetchSite, a as formatNumber, s as serializePages, e as ensureArray } from './packem_shared/index-DjmSPXQS.mjs';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function toArr(any) {
  return any == null ? [] : Array.isArray(any) ? any : [any];
}
__name(toArr, "toArr");
function toVal(out, key, val, opts) {
  var x, old = out[key], nxt = !!~opts.string.indexOf(key) ? val == null || val === true ? "" : String(val) : typeof val === "boolean" ? val : !!~opts.boolean.indexOf(key) ? val === "false" ? false : val === "true" || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;
  out[key] = old == null ? nxt : Array.isArray(old) ? old.concat(nxt) : [old, nxt];
}
__name(toVal, "toVal");
function mri2(args, opts) {
  args = args || [];
  opts = opts || {};
  var k, arr, arg, name, val, out = { _: [] };
  var i = 0, j = 0, idx = 0, len = args.length;
  const alibi = opts.alias !== undefined;
  const strict = opts.unknown !== undefined;
  const defaults = opts.default !== undefined;
  opts.alias = opts.alias || {};
  opts.string = toArr(opts.string);
  opts.boolean = toArr(opts.boolean);
  if (alibi) {
    for (k in opts.alias) {
      arr = opts.alias[k] = toArr(opts.alias[k]);
      for (i = 0; i < arr.length; i++) {
        (opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
      }
    }
  }
  for (i = opts.boolean.length; i-- > 0; ) {
    arr = opts.alias[opts.boolean[i]] || [];
    for (j = arr.length; j-- > 0; ) opts.boolean.push(arr[j]);
  }
  for (i = opts.string.length; i-- > 0; ) {
    arr = opts.alias[opts.string[i]] || [];
    for (j = arr.length; j-- > 0; ) opts.string.push(arr[j]);
  }
  if (defaults) {
    for (k in opts.default) {
      name = typeof opts.default[k];
      arr = opts.alias[k] = opts.alias[k] || [];
      if (opts[name] !== undefined) {
        opts[name].push(k);
        for (i = 0; i < arr.length; i++) {
          opts[name].push(arr[i]);
        }
      }
    }
  }
  const keys = strict ? Object.keys(opts.alias) : [];
  for (i = 0; i < len; i++) {
    arg = args[i];
    if (arg === "--") {
      out._ = out._.concat(args.slice(++i));
      break;
    }
    for (j = 0; j < arg.length; j++) {
      if (arg.charCodeAt(j) !== 45) break;
    }
    if (j === 0) {
      out._.push(arg);
    } else if (arg.substring(j, j + 3) === "no-") {
      name = arg.substring(j + 3);
      if (strict && !~keys.indexOf(name)) {
        return opts.unknown(arg);
      }
      out[name] = false;
    } else {
      for (idx = j + 1; idx < arg.length; idx++) {
        if (arg.charCodeAt(idx) === 61) break;
      }
      name = arg.substring(j, idx);
      val = arg.substring(++idx) || (i + 1 === len || ("" + args[i + 1]).charCodeAt(0) === 45 || args[++i]);
      arr = j === 2 ? [name] : name;
      for (idx = 0; idx < arr.length; idx++) {
        name = arr[idx];
        if (strict && !~keys.indexOf(name)) return opts.unknown("-".repeat(j) + name);
        toVal(out, name, idx + 1 < arr.length || val, opts);
      }
    }
  }
  if (defaults) {
    for (k in opts.default) {
      if (out[k] === undefined) {
        out[k] = opts.default[k];
      }
    }
  }
  if (alibi) {
    for (k in out) {
      arr = opts.alias[k] || [];
      while (arr.length > 0) {
        out[arr.shift()] = out[k];
      }
    }
  }
  return out;
}
__name(mri2, "mri2");
const removeBrackets = /* @__PURE__ */ __name((v) => v.replace(/[<[].+/, "").trim(), "removeBrackets");
const findAllBrackets = /* @__PURE__ */ __name((v) => {
  const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
  const SQUARE_BRACKET_RE_GLOBAL = /\\[([^\\]]+)\\]/g;
  const res = [];
  const parse = /* @__PURE__ */ __name((match) => {
    let variadic = false;
    let value = match[1];
    if (value.startsWith("...")) {
      value = value.slice(3);
      variadic = true;
    }
    return {
      required: match[0].startsWith("<"),
      value,
      variadic
    };
  }, "parse");
  let angledMatch;
  while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(angledMatch));
  }
  let squareMatch;
  while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(squareMatch));
  }
  return res;
}, "findAllBrackets");
const getMriOptions = /* @__PURE__ */ __name((options) => {
  const result = { alias: {}, boolean: [] };
  for (const [index, option] of options.entries()) {
    if (option.names.length > 1) {
      result.alias[option.names[0]] = option.names.slice(1);
    }
    if (option.isBoolean) {
      if (option.negated) {
        const hasStringTypeOption = options.some((o, i) => {
          return i !== index && o.names.some((name) => option.names.includes(name)) && typeof o.required === "boolean";
        });
        if (!hasStringTypeOption) {
          result.boolean.push(option.names[0]);
        }
      } else {
        result.boolean.push(option.names[0]);
      }
    }
  }
  return result;
}, "getMriOptions");
const findLongest = /* @__PURE__ */ __name((arr) => {
  return arr.sort((a, b) => {
    return a.length > b.length ? -1 : 1;
  })[0];
}, "findLongest");
const padRight = /* @__PURE__ */ __name((str, length) => {
  return str.length >= length ? str : \`\${str}\${" ".repeat(length - str.length)}\`;
}, "padRight");
const camelcase = /* @__PURE__ */ __name((input) => {
  return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
    return p1 + p2.toUpperCase();
  });
}, "camelcase");
const setDotProp = /* @__PURE__ */ __name((obj, keys, val) => {
  let i = 0;
  let length = keys.length;
  let t = obj;
  let x;
  for (; i < length; ++i) {
    x = t[keys[i]];
    t = t[keys[i]] = i === length - 1 ? val : x != null ? x : !!~keys[i + 1].indexOf(".") || !(+keys[i + 1] > -1) ? {} : [];
  }
}, "setDotProp");
const setByType = /* @__PURE__ */ __name((obj, transforms) => {
  for (const key of Object.keys(transforms)) {
    const transform = transforms[key];
    if (transform.shouldTransform) {
      obj[key] = Array.prototype.concat.call([], obj[key]);
      if (typeof transform.transformFunction === "function") {
        obj[key] = obj[key].map(transform.transformFunction);
      }
    }
  }
}, "setByType");
const getFileName = /* @__PURE__ */ __name((input) => {
  const m = /([^\\\\\\/]+)$/.exec(input);
  return m ? m[1] : "";
}, "getFileName");
const camelcaseOptionName = /* @__PURE__ */ __name((name) => {
  return name.split(".").map((v, i) => {
    return i === 0 ? camelcase(v) : v;
  }).join(".");
}, "camelcaseOptionName");
class CACError extends Error {
  static {
    __name(this, "CACError");
  }
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
}
class Option {
  static {
    __name(this, "Option");
  }
  constructor(rawName, description, config) {
    this.rawName = rawName;
    this.description = description;
    this.config = Object.assign({}, config);
    rawName = rawName.replace(/\\.\\*/g, "");
    this.negated = false;
    this.names = removeBrackets(rawName).split(",").map((v) => {
      let name = v.trim().replace(/^-{1,2}/, "");
      if (name.startsWith("no-")) {
        this.negated = true;
        name = name.replace(/^no-/, "");
      }
      return camelcaseOptionName(name);
    }).sort((a, b) => a.length > b.length ? 1 : -1);
    this.name = this.names[this.names.length - 1];
    if (this.negated && this.config.default == null) {
      this.config.default = true;
    }
    if (rawName.includes("<")) {
      this.required = true;
    } else if (rawName.includes("[")) {
      this.required = false;
    } else {
      this.isBoolean = true;
    }
  }
}
const processArgs = process.argv;
const platformInfo = \`\${process.platform}-\${process.arch} node-\${process.version}\`;
class Command {
  static {
    __name(this, "Command");
  }
  constructor(rawName, description, config = {}, cli) {
    this.rawName = rawName;
    this.description = description;
    this.config = config;
    this.cli = cli;
    this.options = [];
    this.aliasNames = [];
    this.name = removeBrackets(rawName);
    this.args = findAllBrackets(rawName);
    this.examples = [];
  }
  usage(text) {
    this.usageText = text;
    return this;
  }
  allowUnknownOptions() {
    this.config.allowUnknownOptions = true;
    return this;
  }
  ignoreOptionDefaultValue() {
    this.config.ignoreOptionDefaultValue = true;
    return this;
  }
  version(version, customFlags = "-v, --version") {
    this.versionNumber = version;
    this.option(customFlags, "Display version number");
    return this;
  }
  example(example) {
    this.examples.push(example);
    return this;
  }
  option(rawName, description, config) {
    const option = new Option(rawName, description, config);
    this.options.push(option);
    return this;
  }
  alias(name) {
    this.aliasNames.push(name);
    return this;
  }
  action(callback) {
    this.commandAction = callback;
    return this;
  }
  isMatched(name) {
    return this.name === name || this.aliasNames.includes(name);
  }
  get isDefaultCommand() {
    return this.name === "" || this.aliasNames.includes("!");
  }
  get isGlobalCommand() {
    return this instanceof GlobalCommand;
  }
  hasOption(name) {
    name = name.split(".")[0];
    return this.options.find((option) => {
      return option.names.includes(name);
    });
  }
  outputHelp() {
    const { name, commands } = this.cli;
    const {
      versionNumber,
      options: globalOptions,
      helpCallback
    } = this.cli.globalCommand;
    let sections = [
      {
        body: \`\${name}\${versionNumber ? \`/\${versionNumber}\` : ""}\`
      }
    ];
    sections.push({
      title: "Usage",
      body: \`  $ \${name} \${this.usageText || this.rawName}\`
    });
    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
    if (showCommands) {
      const longestCommandName = findLongest(commands.map((command) => command.rawName));
      sections.push({
        title: "Commands",
        body: commands.map((command) => {
          return \`  \${padRight(command.rawName, longestCommandName.length)}  \${command.description}\`;
        }).join("\\n")
      });
      sections.push({
        title: \`For more info, run any command with the \\\`--help\\\` flag\`,
        body: commands.map((command) => \`  $ \${name}\${command.name === "" ? "" : \` \${command.name}\`} --help\`).join("\\n")
      });
    }
    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...globalOptions || []];
    if (!this.isGlobalCommand && !this.isDefaultCommand) {
      options = options.filter((option) => option.name !== "version");
    }
    if (options.length > 0) {
      const longestOptionName = findLongest(options.map((option) => option.rawName));
      sections.push({
        title: "Options",
        body: options.map((option) => {
          return \`  \${padRight(option.rawName, longestOptionName.length)}  \${option.description} \${option.config.default === undefined ? "" : \`(default: \${option.config.default})\`}\`;
        }).join("\\n")
      });
    }
    if (this.examples.length > 0) {
      sections.push({
        title: "Examples",
        body: this.examples.map((example) => {
          if (typeof example === "function") {
            return example(name);
          }
          return example;
        }).join("\\n")
      });
    }
    if (helpCallback) {
      sections = helpCallback(sections) || sections;
    }
    console.log(sections.map((section) => {
      return section.title ? \`\${section.title}:
\${section.body}\` : section.body;
    }).join("\\n\\n"));
  }
  outputVersion() {
    const { name } = this.cli;
    const { versionNumber } = this.cli.globalCommand;
    if (versionNumber) {
      console.log(\`\${name}/\${versionNumber} \${platformInfo}\`);
    }
  }
  checkRequiredArgs() {
    const minimalArgsCount = this.args.filter((arg) => arg.required).length;
    if (this.cli.args.length < minimalArgsCount) {
      throw new CACError(\`missing required args for command \\\`\${this.rawName}\\\`\`);
    }
  }
  checkUnknownOptions() {
    const { options, globalCommand } = this.cli;
    if (!this.config.allowUnknownOptions) {
      for (const name of Object.keys(options)) {
        if (name !== "--" && !this.hasOption(name) && !globalCommand.hasOption(name)) {
          throw new CACError(\`Unknown option \\\`\${name.length > 1 ? \`--\${name}\` : \`-\${name}\`}\\\`\`);
        }
      }
    }
  }
  checkOptionValue() {
    const { options: parsedOptions, globalCommand } = this.cli;
    const options = [...globalCommand.options, ...this.options];
    for (const option of options) {
      const value = parsedOptions[option.name.split(".")[0]];
      if (option.required) {
        const hasNegated = options.some((o) => o.negated && o.names.includes(option.name));
        if (value === true || value === false && !hasNegated) {
          throw new CACError(\`option \\\`\${option.rawName}\\\` value is missing\`);
        }
      }
    }
  }
}
class GlobalCommand extends Command {
  static {
    __name(this, "GlobalCommand");
  }
  constructor(cli) {
    super("@@global@@", "", {}, cli);
  }
}
var __assign = Object.assign;
class CAC extends EventEmitter {
  static {
    __name(this, "CAC");
  }
  constructor(name = "") {
    super();
    this.name = name;
    this.commands = [];
    this.rawArgs = [];
    this.args = [];
    this.options = {};
    this.globalCommand = new GlobalCommand(this);
    this.globalCommand.usage("<command> [options]");
  }
  usage(text) {
    this.globalCommand.usage(text);
    return this;
  }
  command(rawName, description, config) {
    const command = new Command(rawName, description || "", config, this);
    command.globalCommand = this.globalCommand;
    this.commands.push(command);
    return command;
  }
  option(rawName, description, config) {
    this.globalCommand.option(rawName, description, config);
    return this;
  }
  help(callback) {
    this.globalCommand.option("-h, --help", "Display this message");
    this.globalCommand.helpCallback = callback;
    this.showHelpOnExit = true;
    return this;
  }
  version(version, customFlags = "-v, --version") {
    this.globalCommand.version(version, customFlags);
    this.showVersionOnExit = true;
    return this;
  }
  example(example) {
    this.globalCommand.example(example);
    return this;
  }
  outputHelp() {
    if (this.matchedCommand) {
      this.matchedCommand.outputHelp();
    } else {
      this.globalCommand.outputHelp();
    }
  }
  outputVersion() {
    this.globalCommand.outputVersion();
  }
  setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
    this.args = args;
    this.options = options;
    if (matchedCommand) {
      this.matchedCommand = matchedCommand;
    }
    if (matchedCommandName) {
      this.matchedCommandName = matchedCommandName;
    }
    return this;
  }
  unsetMatchedCommand() {
    this.matchedCommand = undefined;
    this.matchedCommandName = undefined;
  }
  parse(argv = processArgs, {
    run = true
  } = {}) {
    this.rawArgs = argv;
    if (!this.name) {
      this.name = argv[1] ? getFileName(argv[1]) : "cli";
    }
    let shouldParse = true;
    for (const command of this.commands) {
      const parsed = this.mri(argv.slice(2), command);
      const commandName = parsed.args[0];
      if (command.isMatched(commandName)) {
        shouldParse = false;
        const parsedInfo = __assign(__assign({}, parsed), {
          args: parsed.args.slice(1)
        });
        this.setParsedInfo(parsedInfo, command, commandName);
        this.emit(\`command:\${commandName}\`, command);
      }
    }
    if (shouldParse) {
      for (const command of this.commands) {
        if (command.name === "") {
          shouldParse = false;
          const parsed = this.mri(argv.slice(2), command);
          this.setParsedInfo(parsed, command);
          this.emit(\`command:!\`, command);
        }
      }
    }
    if (shouldParse) {
      const parsed = this.mri(argv.slice(2));
      this.setParsedInfo(parsed);
    }
    if (this.options.help && this.showHelpOnExit) {
      this.outputHelp();
      run = false;
      this.unsetMatchedCommand();
    }
    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {
      this.outputVersion();
      run = false;
      this.unsetMatchedCommand();
    }
    const parsedArgv = { args: this.args, options: this.options };
    if (run) {
      this.runMatchedCommand();
    }
    if (!this.matchedCommand && this.args[0]) {
      this.emit("command:*");
    }
    return parsedArgv;
  }
  mri(argv, command) {
    const cliOptions = [
      ...this.globalCommand.options,
      ...command ? command.options : []
    ];
    const mriOptions = getMriOptions(cliOptions);
    let argsAfterDoubleDashes = [];
    const doubleDashesIndex = argv.indexOf("--");
    if (doubleDashesIndex > -1) {
      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
      argv = argv.slice(0, doubleDashesIndex);
    }
    let parsed = mri2(argv, mriOptions);
    parsed = Object.keys(parsed).reduce((res, name) => {
      return __assign(__assign({}, res), {
        [camelcaseOptionName(name)]: parsed[name]
      });
    }, { _: [] });
    const args = parsed._;
    const options = {
      "--": argsAfterDoubleDashes
    };
    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
    let transforms = /* @__PURE__ */ Object.create(null);
    for (const cliOption of cliOptions) {
      if (!ignoreDefault && cliOption.config.default !== undefined) {
        for (const name of cliOption.names) {
          options[name] = cliOption.config.default;
        }
      }
      if (Array.isArray(cliOption.config.type)) {
        if (transforms[cliOption.name] === undefined) {
          transforms[cliOption.name] = /* @__PURE__ */ Object.create(null);
          transforms[cliOption.name]["shouldTransform"] = true;
          transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
        }
      }
    }
    for (const key of Object.keys(parsed)) {
      if (key !== "_") {
        const keys = key.split(".");
        setDotProp(options, keys, parsed[key]);
        setByType(options, transforms);
      }
    }
    return {
      args,
      options
    };
  }
  runMatchedCommand() {
    const { args, options, matchedCommand: command } = this;
    if (!command || !command.commandAction)
      return;
    command.checkUnknownOptions();
    command.checkOptionValue();
    command.checkRequiredArgs();
    const actionArgs = [];
    command.args.forEach((arg, index) => {
      if (arg.variadic) {
        actionArgs.push(args.slice(index));
      } else {
        actionArgs.push(args[index]);
      }
    });
    actionArgs.push(options);
    return command.commandAction.apply(this, actionArgs);
  }
}
const cac = /* @__PURE__ */ __name((name = "") => new CAC(name), "cac");

const version = "0.0.16";

const cli = cac("sitefetch");
cli.command("[url]", "Fetch a site").option("-o, --outfile <path>", "Write the fetched site to a text file").option("--concurrency <number>", "Number of concurrent requests", {
  default: 3
}).option("-m, --match <pattern>", "Only fetch matched pages").option("--content-selector <selector>", "The CSS selector to find content").option("--limit <limit>", "Limit the result to this amount of pages").option("--silent", "Do not print any logs").action(async (url, flags) => {
  if (!url) {
    cli.outputHelp();
    return;
  }
  if (flags.silent) {
    logger.setLevel("silent");
  }
  const pages = await fetchSite(url, {
    concurrency: flags.concurrency,
    match: flags.match && ensureArray(flags.match),
    contentSelector: flags.contentSelector,
    limit: flags.limit
  });
  if (pages.size === 0) {
    logger.warn("No pages found");
    return;
  }
  const pagesArr = [...pages.values()];
  const totalTokenCount = pagesArr.reduce(
    (acc, page) => acc + encode(page.content).length,
    0
  );
  logger.info(
    \`Total token count for \${pages.size} pages: \${formatNumber(
      totalTokenCount
    )}\`
  );
  if (flags.outfile) {
    const output = serializePages(
      pages,
      flags.outfile.endsWith(".json") ? "json" : "text"
    );
    fs.mkdirSync(path.dirname(flags.outfile), { recursive: true });
    fs.writeFileSync(flags.outfile, output, "utf8");
  } else {
    console.log(serializePages(pages, "text"));
  }
});
cli.version(version);
cli.help();
cli.parse();
",
  "import type { Options, FetchSiteResult } from "./types.d.mts";
export declare function fetchSite(url: string, options: Options): Promise<FetchSiteResult>;
export declare function serializePages(pages: FetchSiteResult, format: "json" | "text"): string;
",
  "export { f as fetchSite, s as serializePages } from './packem_shared/index-DjmSPXQS.mjs';
import 'happy-dom';
import 'cheerio';
",
  "type LoggerLevel = "silent" | "warn";
declare class Logger {
    private level?;
    setLevel(level: LoggerLevel): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
}
export declare const logger: Logger;
export {};
",
  "export declare function toMarkdown(html: string): string;
",
  "export type Options = {
    /** How many requests can be made at the same time */
    concurrency?: number;
    /**
     * Match pathname by specific patterns, powered by micromatch
     * Only pages matched by this will be fetched
     */
    match?: string[];
    /**
     * The CSS selector to find content
     */
    contentSelector?: string | ((ctx: {
        pathname: string;
    }) => string | void | undefined);
    /**
     * Limit the result to this amount of pages
     */
    limit?: number;
    /**
     * A custom function to fetch URL
     */
    fetch?: (url: string, init: RequestInit) => Promise<Response>;
};
export type Page = {
    title: string;
    url: string;
    content: string;
};
export type FetchSiteResult = Map<string, Page>;
",
  "export declare function formatNumber(num: number): string;
export declare function matchPath(path: string, pattern: string | string[]): boolean;
export declare function ensureArray<T>(input: T | T[]): T[];
",
  "import { Window } from 'happy-dom';
import Turndown from 'turndown';
import { gfm } from 'turndown-plugin-gfm';
import { load } from 'cheerio';
import micromatch from 'micromatch';

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var eventemitter3 = {exports: {}};

var hasRequiredEventemitter3;

function requireEventemitter3 () {
	if (hasRequiredEventemitter3) return eventemitter3.exports;
	hasRequiredEventemitter3 = 1;
	(function (module) {
		var __defProp = Object.defineProperty;
		var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
		var has = Object.prototype.hasOwnProperty;
		var prefix = "~";
		function Events() {
		}
		__name(Events, "Events");
		if (Object.create) {
		  Events.prototype = /* @__PURE__ */ Object.create(null);
		  if (!new Events().__proto__) prefix = false;
		}
		function EE(fn, context, once2) {
		  this.fn = fn;
		  this.context = context;
		  this.once = once2 || false;
		}
		__name(EE, "EE");
		function addListener(emitter, event, fn, context, once2) {
		  if (typeof fn !== "function") {
		    throw new TypeError("The listener must be a function");
		  }
		  var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
		  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		  else emitter._events[evt] = [emitter._events[evt], listener];
		  return emitter;
		}
		__name(addListener, "addListener");
		function clearEvent(emitter, evt) {
		  if (--emitter._eventsCount === 0) emitter._events = new Events();
		  else delete emitter._events[evt];
		}
		__name(clearEvent, "clearEvent");
		function EventEmitter() {
		  this._events = new Events();
		  this._eventsCount = 0;
		}
		__name(EventEmitter, "EventEmitter");
		EventEmitter.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
		  var names = [], events, name;
		  if (this._eventsCount === 0) return names;
		  for (name in events = this._events) {
		    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		  }
		  if (Object.getOwnPropertySymbols) {
		    return names.concat(Object.getOwnPropertySymbols(events));
		  }
		  return names;
		}, "eventNames");
		EventEmitter.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
		  var evt = prefix ? prefix + event : event, handlers = this._events[evt];
		  if (!handlers) return [];
		  if (handlers.fn) return [handlers.fn];
		  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
		    ee[i] = handlers[i].fn;
		  }
		  return ee;
		}, "listeners");
		EventEmitter.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
		  var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
		  if (!listeners2) return 0;
		  if (listeners2.fn) return 1;
		  return listeners2.length;
		}, "listenerCount");
		EventEmitter.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
		  var evt = prefix ? prefix + event : event;
		  if (!this._events[evt]) return false;
		  var listeners2 = this._events[evt], len = arguments.length, args, i;
		  if (listeners2.fn) {
		    if (listeners2.once) this.removeListener(event, listeners2.fn, undefined, true);
		    switch (len) {
		      case 1:
		        return listeners2.fn.call(listeners2.context), true;
		      case 2:
		        return listeners2.fn.call(listeners2.context, a1), true;
		      case 3:
		        return listeners2.fn.call(listeners2.context, a1, a2), true;
		      case 4:
		        return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
		      case 5:
		        return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
		      case 6:
		        return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
		    }
		    for (i = 1, args = new Array(len - 1); i < len; i++) {
		      args[i - 1] = arguments[i];
		    }
		    listeners2.fn.apply(listeners2.context, args);
		  } else {
		    var length = listeners2.length, j;
		    for (i = 0; i < length; i++) {
		      if (listeners2[i].once) this.removeListener(event, listeners2[i].fn, undefined, true);
		      switch (len) {
		        case 1:
		          listeners2[i].fn.call(listeners2[i].context);
		          break;
		        case 2:
		          listeners2[i].fn.call(listeners2[i].context, a1);
		          break;
		        case 3:
		          listeners2[i].fn.call(listeners2[i].context, a1, a2);
		          break;
		        case 4:
		          listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
		          break;
		        default:
		          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
		            args[j - 1] = arguments[j];
		          }
		          listeners2[i].fn.apply(listeners2[i].context, args);
		      }
		    }
		  }
		  return true;
		}, "emit");
		EventEmitter.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
		  return addListener(this, event, fn, context, false);
		}, "on");
		EventEmitter.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
		  return addListener(this, event, fn, context, true);
		}, "once");
		EventEmitter.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once2) {
		  var evt = prefix ? prefix + event : event;
		  if (!this._events[evt]) return this;
		  if (!fn) {
		    clearEvent(this, evt);
		    return this;
		  }
		  var listeners2 = this._events[evt];
		  if (listeners2.fn) {
		    if (listeners2.fn === fn && (!once2 || listeners2.once) && (!context || listeners2.context === context)) {
		      clearEvent(this, evt);
		    }
		  } else {
		    for (var i = 0, events = [], length = listeners2.length; i < length; i++) {
		      if (listeners2[i].fn !== fn || once2 && !listeners2[i].once || context && listeners2[i].context !== context) {
		        events.push(listeners2[i]);
		      }
		    }
		    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
		    else clearEvent(this, evt);
		  }
		  return this;
		}, "removeListener");
		EventEmitter.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
		  var evt;
		  if (event) {
		    evt = prefix ? prefix + event : event;
		    if (this._events[evt]) clearEvent(this, evt);
		  } else {
		    this._events = new Events();
		    this._eventsCount = 0;
		  }
		  return this;
		}, "removeAllListeners");
		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
		EventEmitter.prototype.addListener = EventEmitter.prototype.on;
		EventEmitter.prefixed = prefix;
		EventEmitter.EventEmitter = EventEmitter;
		{
		  module.exports = EventEmitter;
		} 
	} (eventemitter3));
	return eventemitter3.exports;
}

var eventemitter3Exports = requireEventemitter3();
const EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

var __defProp$7 = Object.defineProperty;
var __name$7 = (target, value) => __defProp$7(target, "name", { value, configurable: true });
class TimeoutError extends Error {
  static {
    __name$7(this, "TimeoutError");
  }
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
}
class AbortError extends Error {
  static {
    __name$7(this, "AbortError");
  }
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
}
const getDOMException = /* @__PURE__ */ __name$7((errorMessage) => globalThis.DOMException === undefined ? new AbortError(errorMessage) : new DOMException(errorMessage), "getDOMException");
const getAbortedReason = /* @__PURE__ */ __name$7((signal) => {
  const reason = signal.reason === undefined ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
}, "getAbortedReason");
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(\`Expected \\\`milliseconds\\\` to be a positive number, got \\\`\${milliseconds}\\\`\`);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      const abortHandler = /* @__PURE__ */ __name$7(() => {
        reject(getAbortedReason(signal));
      }, "abortHandler");
      signal.addEventListener("abort", abortHandler, { once: true });
      promise.finally(() => {
        signal.removeEventListener("abort", abortHandler);
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(undefined, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message === false) {
        resolve();
      } else if (message instanceof Error) {
        reject(message);
      } else {
        timeoutError.message = message ?? \`Promise timed out after \${milliseconds} milliseconds\`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(undefined, timer);
    timer = undefined;
  };
  return cancelablePromise;
}
__name$7(pTimeout, "pTimeout");

var __defProp$6 = Object.defineProperty;
var __name$6 = (target, value) => __defProp$6(target, "name", { value, configurable: true });
function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}
__name$6(lowerBound, "lowerBound");

var __defProp$5 = Object.defineProperty;
var __name$5 = (target, value) => __defProp$5(target, "name", { value, configurable: true });
class PriorityQueue {
  static {
    __name$5(this, "PriorityQueue");
  }
  #queue = [];
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      id: options.id,
      run
    };
    if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {
      this.#queue.push(element);
      return;
    }
    const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);
    this.#queue.splice(index, 0, element);
  }
  setPriority(id, priority) {
    const index = this.#queue.findIndex((element) => element.id === id);
    if (index === -1) {
      throw new ReferenceError(\`No promise function with the id "\${id}" exists in the queue.\`);
    }
    const [item] = this.#queue.splice(index, 1);
    this.enqueue(item.run, { priority, id });
  }
  dequeue() {
    const item = this.#queue.shift();
    return item?.run;
  }
  filter(options) {
    return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return this.#queue.length;
  }
}

var __defProp$4 = Object.defineProperty;
var __name$4 = (target, value) => __defProp$4(target, "name", { value, configurable: true });
class PQueue extends EventEmitter {
  static {
    __name$4(this, "PQueue");
  }
  #carryoverConcurrencyCount;
  #isIntervalIgnored;
  #intervalCount = 0;
  #intervalCap;
  #interval;
  #intervalEnd = 0;
  #intervalId;
  #timeoutId;
  #queue;
  #queueClass;
  #pending = 0;
  // The \`!\` is needed because of https://github.com/microsoft/TypeScript/issues/32194
  #concurrency;
  #isPaused;
  #throwOnTimeout;
  // Use to assign a unique identifier to a promise function, if not explicitly specified
  #idAssigner = 1n;
  /**
      Per-operation timeout in milliseconds. Operations fulfill once \`timeout\` elapses if they haven't already.
  
      Applies to each future operation.
      */
  timeout;
  // TODO: The \`throwOnTimeout\` option should affect the return types of \`add()\` and \`addAll()\`
  constructor(options) {
    super();
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(\`Expected \\\`intervalCap\\\` to be a number from 1 and up, got \\\`\${options.intervalCap?.toString() ?? ""}\\\` (\${typeof options.intervalCap})\`);
    }
    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(\`Expected \\\`interval\\\` to be a finite number >= 0, got \\\`\${options.interval?.toString() ?? ""}\\\` (\${typeof options.interval})\`);
    }
    this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
    this.#intervalCap = options.intervalCap;
    this.#interval = options.interval;
    this.#queue = new options.queueClass();
    this.#queueClass = options.queueClass;
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    this.#throwOnTimeout = options.throwOnTimeout === true;
    this.#isPaused = options.autoStart === false;
  }
  get #doesIntervalAllowAnother() {
    return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
  }
  get #doesConcurrentAllowAnother() {
    return this.#pending < this.#concurrency;
  }
  #next() {
    this.#pending--;
    this.#tryToStartAnother();
    this.emit("next");
  }
  #onResumeInterval() {
    this.#onInterval();
    this.#initializeIntervalIfNeeded();
    this.#timeoutId = undefined;
  }
  get #isIntervalPaused() {
    const now = Date.now();
    if (this.#intervalId === undefined) {
      const delay = this.#intervalEnd - now;
      if (delay < 0) {
        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
      } else {
        if (this.#timeoutId === undefined) {
          this.#timeoutId = setTimeout(() => {
            this.#onResumeInterval();
          }, delay);
        }
        return true;
      }
    }
    return false;
  }
  #tryToStartAnother() {
    if (this.#queue.size === 0) {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
      }
      this.#intervalId = undefined;
      this.emit("empty");
      if (this.#pending === 0) {
        this.emit("idle");
      }
      return false;
    }
    if (!this.#isPaused) {
      const canInitializeInterval = !this.#isIntervalPaused;
      if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
        const job = this.#queue.dequeue();
        if (!job) {
          return false;
        }
        this.emit("active");
        job();
        if (canInitializeInterval) {
          this.#initializeIntervalIfNeeded();
        }
        return true;
      }
    }
    return false;
  }
  #initializeIntervalIfNeeded() {
    if (this.#isIntervalIgnored || this.#intervalId !== undefined) {
      return;
    }
    this.#intervalId = setInterval(() => {
      this.#onInterval();
    }, this.#interval);
    this.#intervalEnd = Date.now() + this.#interval;
  }
  #onInterval() {
    if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
      clearInterval(this.#intervalId);
      this.#intervalId = undefined;
    }
    this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
    this.#processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  #processQueue() {
    while (this.#tryToStartAnother()) {
    }
  }
  get concurrency() {
    return this.#concurrency;
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(\`Expected \\\`concurrency\\\` to be a number from 1 and up, got \\\`\${newConcurrency}\\\` (\${typeof newConcurrency})\`);
    }
    this.#concurrency = newConcurrency;
    this.#processQueue();
  }
  async #throwOnAbort(signal) {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(signal.reason);
      }, { once: true });
    });
  }
  /**
      Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
  
      For example, this can be used to prioritize a promise function to run earlier.
  
      \`\`\`js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 0, id: '🦀'});
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦄', {priority: 1});
  
      queue.setPriority('🦀', 2);
      \`\`\`
  
      In this case, the promise function with \`id: '🦀'\` runs second.
  
      You can also deprioritize a promise function to delay its execution:
  
      \`\`\`js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 1, id: '🦀'});
      queue.add(async () => '🦄');
      queue.add(async () => '🦄', {priority: 0});
  
      queue.setPriority('🦀', -1);
      \`\`\`
      Here, the promise function with \`id: '🦀'\` executes last.
      */
  setPriority(id, priority) {
    this.#queue.setPriority(id, priority);
  }
  async add(function_, options = {}) {
    options.id ??= (this.#idAssigner++).toString();
    options = {
      timeout: this.timeout,
      throwOnTimeout: this.#throwOnTimeout,
      ...options
    };
    return new Promise((resolve, reject) => {
      this.#queue.enqueue(async () => {
        this.#pending++;
        this.#intervalCount++;
        try {
          options.signal?.throwIfAborted();
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
          }
          if (options.signal) {
            operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          this.#next();
        }
      }, options);
      this.emit("add");
      this.#tryToStartAnother();
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via \`options.autoStart = false\` or by \`.pause()\` method.)
  */
  start() {
    if (!this.#isPaused) {
      return this;
    }
    this.#isPaused = false;
    this.#processQueue();
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this.#isPaused = true;
  }
  /**
  Clear the queue.
  */
  clear() {
    this.#queue = new this.#queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: \`queue.size < limit\`.
  
      If you want to avoid having the queue grow beyond a certain size you can \`await queue.onSizeLessThan()\` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to \`concurrency\` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (this.#queue.size < limit) {
      return;
    }
    await this.#onEvent("next", () => this.#queue.size < limit);
  }
  /**
      The difference with \`.onEmpty\` is that \`.onIdle\` guarantees that all work from the queue has finished. \`.onEmpty\` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; \`queue.size === 0 && queue.pending === 0\`.
      */
  async onIdle() {
    if (this.#pending === 0 && this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("idle");
  }
  async #onEvent(event, filter) {
    return new Promise((resolve) => {
      const listener = /* @__PURE__ */ __name$4(() => {
        if (filter && !filter()) {
          return;
        }
        this.off(event, listener);
        resolve();
      }, "listener");
      this.on(event, listener);
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return this.#queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return this.#queue.filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return this.#pending;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this.#isPaused;
  }
}

var Readability = {exports: {}};

var hasRequiredReadability$1;

function requireReadability$1 () {
	if (hasRequiredReadability$1) return Readability.exports;
	hasRequiredReadability$1 = 1;
	(function (module) {
		var __defProp = Object.defineProperty;
		var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
		function Readability(doc, options) {
		  if (options && options.documentElement) {
		    doc = options;
		    options = arguments[2];
		  } else if (!doc || !doc.documentElement) {
		    throw new Error("First argument to Readability constructor should be a document object.");
		  }
		  options = options || {};
		  this._doc = doc;
		  this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;
		  this._articleTitle = null;
		  this._articleByline = null;
		  this._articleDir = null;
		  this._articleSiteName = null;
		  this._attempts = [];
		  this._debug = !!options.debug;
		  this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
		  this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
		  this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
		  this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);
		  this._keepClasses = !!options.keepClasses;
		  this._serializer = options.serializer || function(el) {
		    return el.innerHTML;
		  };
		  this._disableJSONLD = !!options.disableJSONLD;
		  this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;
		  this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;
		  if (this._debug) {
		    let logNode = /* @__PURE__ */ __name(function(node) {
		      if (node.nodeType == node.TEXT_NODE) {
		        return \`\${node.nodeName} ("\${node.textContent}")\`;
		      }
		      let attrPairs = Array.from(node.attributes || [], function(attr) {
		        return \`\${attr.name}="\${attr.value}"\`;
		      }).join(" ");
		      return \`<\${node.localName} \${attrPairs}>\`;
		    }, "logNode");
		    this.log = function() {
		      if (typeof console !== "undefined") {
		        let args = Array.from(arguments, (arg) => {
		          if (arg && arg.nodeType == this.ELEMENT_NODE) {
		            return logNode(arg);
		          }
		          return arg;
		        });
		        args.unshift("Reader: (Readability)");
		        console.log.apply(console, args);
		      } else if (typeof dump !== "undefined") {
		        var msg = Array.prototype.map.call(arguments, function(x) {
		          return x && x.nodeName ? logNode(x) : x;
		        }).join(" ");
		        dump("Reader: (Readability) " + msg + "\\n");
		      }
		    };
		  } else {
		    this.log = function() {
		    };
		  }
		}
		__name(Readability, "Readability");
		Readability.prototype = {
		  FLAG_STRIP_UNLIKELYS: 1,
		  FLAG_WEIGHT_CLASSES: 2,
		  FLAG_CLEAN_CONDITIONALLY: 4,
		  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
		  ELEMENT_NODE: 1,
		  TEXT_NODE: 3,
		  // Max number of nodes supported by this parser. Default: 0 (no limit)
		  DEFAULT_MAX_ELEMS_TO_PARSE: 0,
		  // The number of top candidates to consider when analysing how
		  // tight the competition is among candidates.
		  DEFAULT_N_TOP_CANDIDATES: 5,
		  // Element tags to score by default.
		  DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),
		  // The default number of chars an article must have in order to return a result
		  DEFAULT_CHAR_THRESHOLD: 500,
		  // All of the regular expressions in use within readability.
		  // Defined up here so we don't instantiate them repeatedly in loops.
		  REGEXPS: {
		    // NOTE: These two regular expressions are duplicated in
		    // Readability-readerable.js. Please keep both copies in sync.
		    unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
		    okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,
		    positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,
		    negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,
		    extraneous: /print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single|utility/i,
		    byline: /byline|author|dateline|writtenby|p-author/i,
		    replaceFonts: /<(\\/?)font[^>]*>/gi,
		    normalize: /\\s{2,}/g,
		    videos: /\\/\\/(www\\.)?((dailymotion|youtube|youtube-nocookie|player\\.vimeo|v\\.qq)\\.com|(archive|upload\\.wikimedia)\\.org|player\\.twitch\\.tv)/i,
		    shareElements: /(\\b|_)(share|sharedaddy)(\\b|_)/i,
		    nextLink: /(next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/i,
		    prevLink: /(prev|earl|old|new|<|«)/i,
		    tokenize: /\\W+/g,
		    whitespace: /^\\s*$/,
		    hasContent: /\\S$/,
		    hashUrl: /^#.+/,
		    srcsetUrl: /(\\S+)(\\s+[\\d.]+[xw])?(\\s*(?:,|$))/g,
		    b64DataUrl: /^data:\\s*([^\\s;,]+)\\s*;\\s*base64\\s*,/i,
		    // Commas as used in Latin, Sindhi, Chinese and various other scripts.
		    // see: https://en.wikipedia.org/wiki/Comma#Comma_variants
		    commas: /\\u002C|\\u060C|\\uFE50|\\uFE10|\\uFE11|\\u2E41|\\u2E34|\\u2E32|\\uFF0C/g,
		    // See: https://schema.org/Article
		    jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/
		  },
		  UNLIKELY_ROLES: ["menu", "menubar", "complementary", "navigation", "alert", "alertdialog", "dialog"],
		  DIV_TO_P_ELEMS: /* @__PURE__ */ new Set(["BLOCKQUOTE", "DL", "DIV", "IMG", "OL", "P", "PRE", "TABLE", "UL"]),
		  ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P"],
		  PRESENTATIONAL_ATTRIBUTES: ["align", "background", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "hspace", "rules", "style", "valign", "vspace"],
		  DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],
		  // The commented out elements qualify as phrasing content but tend to be
		  // removed by readability when put into paragraphs, so we ignore them here.
		  PHRASING_ELEMS: [
		    // "CANVAS", "IFRAME", "SVG", "VIDEO",
		    "ABBR",
		    "AUDIO",
		    "B",
		    "BDO",
		    "BR",
		    "BUTTON",
		    "CITE",
		    "CODE",
		    "DATA",
		    "DATALIST",
		    "DFN",
		    "EM",
		    "EMBED",
		    "I",
		    "IMG",
		    "INPUT",
		    "KBD",
		    "LABEL",
		    "MARK",
		    "MATH",
		    "METER",
		    "NOSCRIPT",
		    "OBJECT",
		    "OUTPUT",
		    "PROGRESS",
		    "Q",
		    "RUBY",
		    "SAMP",
		    "SCRIPT",
		    "SELECT",
		    "SMALL",
		    "SPAN",
		    "STRONG",
		    "SUB",
		    "SUP",
		    "TEXTAREA",
		    "TIME",
		    "VAR",
		    "WBR"
		  ],
		  // These are the classes that readability sets itself.
		  CLASSES_TO_PRESERVE: ["page"],
		  // These are the list of HTML entities that need to be escaped.
		  HTML_ESCAPE_MAP: {
		    "lt": "<",
		    "gt": ">",
		    "amp": "&",
		    "quot": '"',
		    "apos": "'"
		  },
		  /**
		   * Run any post-process modifications to article content as necessary.
		   *
		   * @param Element
		   * @return void
		  **/
		  _postProcessContent: /* @__PURE__ */ __name(function(articleContent) {
		    this._fixRelativeUris(articleContent);
		    this._simplifyNestedElements(articleContent);
		    if (!this._keepClasses) {
		      this._cleanClasses(articleContent);
		    }
		  }, "_postProcessContent"),
		  /**
		   * Iterates over a NodeList, calls \`filterFn\` for each node and removes node
		   * if function returned \`true\`.
		   *
		   * If function is not passed, removes all the nodes in node list.
		   *
		   * @param NodeList nodeList The nodes to operate on
		   * @param Function filterFn the function to use as a filter
		   * @return void
		   */
		  _removeNodes: /* @__PURE__ */ __name(function(nodeList, filterFn) {
		    if (this._docJSDOMParser && nodeList._isLiveNodeList) {
		      throw new Error("Do not pass live node lists to _removeNodes");
		    }
		    for (var i = nodeList.length - 1; i >= 0; i--) {
		      var node = nodeList[i];
		      var parentNode = node.parentNode;
		      if (parentNode) {
		        if (!filterFn || filterFn.call(this, node, i, nodeList)) {
		          parentNode.removeChild(node);
		        }
		      }
		    }
		  }, "_removeNodes"),
		  /**
		   * Iterates over a NodeList, and calls _setNodeTag for each node.
		   *
		   * @param NodeList nodeList The nodes to operate on
		   * @param String newTagName the new tag name to use
		   * @return void
		   */
		  _replaceNodeTags: /* @__PURE__ */ __name(function(nodeList, newTagName) {
		    if (this._docJSDOMParser && nodeList._isLiveNodeList) {
		      throw new Error("Do not pass live node lists to _replaceNodeTags");
		    }
		    for (const node of nodeList) {
		      this._setNodeTag(node, newTagName);
		    }
		  }, "_replaceNodeTags"),
		  /**
		   * Iterate over a NodeList, which doesn't natively fully implement the Array
		   * interface.
		   *
		   * For convenience, the current object context is applied to the provided
		   * iterate function.
		   *
		   * @param  NodeList nodeList The NodeList.
		   * @param  Function fn       The iterate function.
		   * @return void
		   */
		  _forEachNode: /* @__PURE__ */ __name(function(nodeList, fn) {
		    Array.prototype.forEach.call(nodeList, fn, this);
		  }, "_forEachNode"),
		  /**
		   * Iterate over a NodeList, and return the first node that passes
		   * the supplied test function
		   *
		   * For convenience, the current object context is applied to the provided
		   * test function.
		   *
		   * @param  NodeList nodeList The NodeList.
		   * @param  Function fn       The test function.
		   * @return void
		   */
		  _findNode: /* @__PURE__ */ __name(function(nodeList, fn) {
		    return Array.prototype.find.call(nodeList, fn, this);
		  }, "_findNode"),
		  /**
		   * Iterate over a NodeList, return true if any of the provided iterate
		   * function calls returns true, false otherwise.
		   *
		   * For convenience, the current object context is applied to the
		   * provided iterate function.
		   *
		   * @param  NodeList nodeList The NodeList.
		   * @param  Function fn       The iterate function.
		   * @return Boolean
		   */
		  _someNode: /* @__PURE__ */ __name(function(nodeList, fn) {
		    return Array.prototype.some.call(nodeList, fn, this);
		  }, "_someNode"),
		  /**
		   * Iterate over a NodeList, return true if all of the provided iterate
		   * function calls return true, false otherwise.
		   *
		   * For convenience, the current object context is applied to the
		   * provided iterate function.
		   *
		   * @param  NodeList nodeList The NodeList.
		   * @param  Function fn       The iterate function.
		   * @return Boolean
		   */
		  _everyNode: /* @__PURE__ */ __name(function(nodeList, fn) {
		    return Array.prototype.every.call(nodeList, fn, this);
		  }, "_everyNode"),
		  /**
		   * Concat all nodelists passed as arguments.
		   *
		   * @return ...NodeList
		   * @return Array
		   */
		  _concatNodeLists: /* @__PURE__ */ __name(function() {
		    var slice = Array.prototype.slice;
		    var args = slice.call(arguments);
		    var nodeLists = args.map(function(list) {
		      return slice.call(list);
		    });
		    return Array.prototype.concat.apply([], nodeLists);
		  }, "_concatNodeLists"),
		  _getAllNodesWithTag: /* @__PURE__ */ __name(function(node, tagNames) {
		    if (node.querySelectorAll) {
		      return node.querySelectorAll(tagNames.join(","));
		    }
		    return [].concat.apply([], tagNames.map(function(tag) {
		      var collection = node.getElementsByTagName(tag);
		      return Array.isArray(collection) ? collection : Array.from(collection);
		    }));
		  }, "_getAllNodesWithTag"),
		  /**
		   * Removes the class="" attribute from every element in the given
		   * subtree, except those that match CLASSES_TO_PRESERVE and
		   * the classesToPreserve array from the options object.
		   *
		   * @param Element
		   * @return void
		   */
		  _cleanClasses: /* @__PURE__ */ __name(function(node) {
		    var classesToPreserve = this._classesToPreserve;
		    var className = (node.getAttribute("class") || "").split(/\\s+/).filter(function(cls) {
		      return classesToPreserve.indexOf(cls) != -1;
		    }).join(" ");
		    if (className) {
		      node.setAttribute("class", className);
		    } else {
		      node.removeAttribute("class");
		    }
		    for (node = node.firstElementChild; node; node = node.nextElementSibling) {
		      this._cleanClasses(node);
		    }
		  }, "_cleanClasses"),
		  /**
		   * Converts each <a> and <img> uri in the given element to an absolute URI,
		   * ignoring #ref URIs.
		   *
		   * @param Element
		   * @return void
		   */
		  _fixRelativeUris: /* @__PURE__ */ __name(function(articleContent) {
		    var baseURI = this._doc.baseURI;
		    var documentURI = this._doc.documentURI;
		    function toAbsoluteURI(uri) {
		      if (baseURI == documentURI && uri.charAt(0) == "#") {
		        return uri;
		      }
		      try {
		        return new URL(uri, baseURI).href;
		      } catch (ex) {
		      }
		      return uri;
		    }
		    __name(toAbsoluteURI, "toAbsoluteURI");
		    var links = this._getAllNodesWithTag(articleContent, ["a"]);
		    this._forEachNode(links, function(link) {
		      var href = link.getAttribute("href");
		      if (href) {
		        if (href.indexOf("javascript:") === 0) {
		          if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {
		            var text = this._doc.createTextNode(link.textContent);
		            link.parentNode.replaceChild(text, link);
		          } else {
		            var container = this._doc.createElement("span");
		            while (link.firstChild) {
		              container.appendChild(link.firstChild);
		            }
		            link.parentNode.replaceChild(container, link);
		          }
		        } else {
		          link.setAttribute("href", toAbsoluteURI(href));
		        }
		      }
		    });
		    var medias = this._getAllNodesWithTag(articleContent, [
		      "img",
		      "picture",
		      "figure",
		      "video",
		      "audio",
		      "source"
		    ]);
		    this._forEachNode(medias, function(media) {
		      var src = media.getAttribute("src");
		      var poster = media.getAttribute("poster");
		      var srcset = media.getAttribute("srcset");
		      if (src) {
		        media.setAttribute("src", toAbsoluteURI(src));
		      }
		      if (poster) {
		        media.setAttribute("poster", toAbsoluteURI(poster));
		      }
		      if (srcset) {
		        var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_, p1, p2, p3) {
		          return toAbsoluteURI(p1) + (p2 || "") + p3;
		        });
		        media.setAttribute("srcset", newSrcset);
		      }
		    });
		  }, "_fixRelativeUris"),
		  _simplifyNestedElements: /* @__PURE__ */ __name(function(articleContent) {
		    var node = articleContent;
		    while (node) {
		      if (node.parentNode && ["DIV", "SECTION"].includes(node.tagName) && !(node.id && node.id.startsWith("readability"))) {
		        if (this._isElementWithoutContent(node)) {
		          node = this._removeAndGetNext(node);
		          continue;
		        } else if (this._hasSingleTagInsideElement(node, "DIV") || this._hasSingleTagInsideElement(node, "SECTION")) {
		          var child = node.children[0];
		          for (var i = 0; i < node.attributes.length; i++) {
		            child.setAttribute(node.attributes[i].name, node.attributes[i].value);
		          }
		          node.parentNode.replaceChild(child, node);
		          node = child;
		          continue;
		        }
		      }
		      node = this._getNextNode(node);
		    }
		  }, "_simplifyNestedElements"),
		  /**
		   * Get the article title as an H1.
		   *
		   * @return string
		   **/
		  _getArticleTitle: /* @__PURE__ */ __name(function() {
		    var doc = this._doc;
		    var curTitle = "";
		    var origTitle = "";
		    try {
		      curTitle = origTitle = doc.title.trim();
		      if (typeof curTitle !== "string")
		        curTitle = origTitle = this._getInnerText(doc.getElementsByTagName("title")[0]);
		    } catch (e) {
		    }
		    var titleHadHierarchicalSeparators = false;
		    function wordCount(str) {
		      return str.split(/\\s+/).length;
		    }
		    __name(wordCount, "wordCount");
		    if (/ [\\|\\-\\\\\\/>»] /.test(curTitle)) {
		      titleHadHierarchicalSeparators = / [\\\\\\/>»] /.test(curTitle);
		      curTitle = origTitle.replace(/(.*)[\\|\\-\\\\\\/>»] .*/gi, "$1");
		      if (wordCount(curTitle) < 3)
		        curTitle = origTitle.replace(/[^\\|\\-\\\\\\/>»]*[\\|\\-\\\\\\/>»](.*)/gi, "$1");
		    } else if (curTitle.indexOf(": ") !== -1) {
		      var headings = this._concatNodeLists(
		        doc.getElementsByTagName("h1"),
		        doc.getElementsByTagName("h2")
		      );
		      var trimmedTitle = curTitle.trim();
		      var match = this._someNode(headings, function(heading) {
		        return heading.textContent.trim() === trimmedTitle;
		      });
		      if (!match) {
		        curTitle = origTitle.substring(origTitle.lastIndexOf(":") + 1);
		        if (wordCount(curTitle) < 3) {
		          curTitle = origTitle.substring(origTitle.indexOf(":") + 1);
		        } else if (wordCount(origTitle.substr(0, origTitle.indexOf(":"))) > 5) {
		          curTitle = origTitle;
		        }
		      }
		    } else if (curTitle.length > 150 || curTitle.length < 15) {
		      var hOnes = doc.getElementsByTagName("h1");
		      if (hOnes.length === 1)
		        curTitle = this._getInnerText(hOnes[0]);
		    }
		    curTitle = curTitle.trim().replace(this.REGEXPS.normalize, " ");
		    var curTitleWordCount = wordCount(curTitle);
		    if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\\|\\-\\\\\\/>»]+/g, "")) - 1)) {
		      curTitle = origTitle;
		    }
		    return curTitle;
		  }, "_getArticleTitle"),
		  /**
		   * Prepare the HTML document for readability to scrape it.
		   * This includes things like stripping javascript, CSS, and handling terrible markup.
		   *
		   * @return void
		   **/
		  _prepDocument: /* @__PURE__ */ __name(function() {
		    var doc = this._doc;
		    this._removeNodes(this._getAllNodesWithTag(doc, ["style"]));
		    if (doc.body) {
		      this._replaceBrs(doc.body);
		    }
		    this._replaceNodeTags(this._getAllNodesWithTag(doc, ["font"]), "SPAN");
		  }, "_prepDocument"),
		  /**
		   * Finds the next node, starting from the given node, and ignoring
		   * whitespace in between. If the given node is an element, the same node is
		   * returned.
		   */
		  _nextNode: /* @__PURE__ */ __name(function(node) {
		    var next = node;
		    while (next && next.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next.textContent)) {
		      next = next.nextSibling;
		    }
		    return next;
		  }, "_nextNode"),
		  /**
		   * Replaces 2 or more successive <br> elements with a single <p>.
		   * Whitespace between <br> elements are ignored. For example:
		   *   <div>foo<br>bar<br> <br><br>abc</div>
		   * will become:
		   *   <div>foo<br>bar<p>abc</p></div>
		   */
		  _replaceBrs: /* @__PURE__ */ __name(function(elem) {
		    this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function(br) {
		      var next = br.nextSibling;
		      var replaced = false;
		      while ((next = this._nextNode(next)) && next.tagName == "BR") {
		        replaced = true;
		        var brSibling = next.nextSibling;
		        next.parentNode.removeChild(next);
		        next = brSibling;
		      }
		      if (replaced) {
		        var p = this._doc.createElement("p");
		        br.parentNode.replaceChild(p, br);
		        next = p.nextSibling;
		        while (next) {
		          if (next.tagName == "BR") {
		            var nextElem = this._nextNode(next.nextSibling);
		            if (nextElem && nextElem.tagName == "BR")
		              break;
		          }
		          if (!this._isPhrasingContent(next))
		            break;
		          var sibling = next.nextSibling;
		          p.appendChild(next);
		          next = sibling;
		        }
		        while (p.lastChild && this._isWhitespace(p.lastChild)) {
		          p.removeChild(p.lastChild);
		        }
		        if (p.parentNode.tagName === "P")
		          this._setNodeTag(p.parentNode, "DIV");
		      }
		    });
		  }, "_replaceBrs"),
		  _setNodeTag: /* @__PURE__ */ __name(function(node, tag) {
		    this.log("_setNodeTag", node, tag);
		    if (this._docJSDOMParser) {
		      node.localName = tag.toLowerCase();
		      node.tagName = tag.toUpperCase();
		      return node;
		    }
		    var replacement = node.ownerDocument.createElement(tag);
		    while (node.firstChild) {
		      replacement.appendChild(node.firstChild);
		    }
		    node.parentNode.replaceChild(replacement, node);
		    if (node.readability)
		      replacement.readability = node.readability;
		    for (var i = 0; i < node.attributes.length; i++) {
		      try {
		        replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);
		      } catch (ex) {
		      }
		    }
		    return replacement;
		  }, "_setNodeTag"),
		  /**
		   * Prepare the article node for display. Clean out any inline styles,
		   * iframes, forms, strip extraneous <p> tags, etc.
		   *
		   * @param Element
		   * @return void
		   **/
		  _prepArticle: /* @__PURE__ */ __name(function(articleContent) {
		    this._cleanStyles(articleContent);
		    this._markDataTables(articleContent);
		    this._fixLazyImages(articleContent);
		    this._cleanConditionally(articleContent, "form");
		    this._cleanConditionally(articleContent, "fieldset");
		    this._clean(articleContent, "object");
		    this._clean(articleContent, "embed");
		    this._clean(articleContent, "footer");
		    this._clean(articleContent, "link");
		    this._clean(articleContent, "aside");
		    var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;
		    this._forEachNode(articleContent.children, function(topCandidate) {
		      this._cleanMatchedNodes(topCandidate, function(node, matchString) {
		        return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;
		      });
		    });
		    this._clean(articleContent, "iframe");
		    this._clean(articleContent, "input");
		    this._clean(articleContent, "textarea");
		    this._clean(articleContent, "select");
		    this._clean(articleContent, "button");
		    this._cleanHeaders(articleContent);
		    this._cleanConditionally(articleContent, "table");
		    this._cleanConditionally(articleContent, "ul");
		    this._cleanConditionally(articleContent, "div");
		    this._replaceNodeTags(this._getAllNodesWithTag(articleContent, ["h1"]), "h2");
		    this._removeNodes(this._getAllNodesWithTag(articleContent, ["p"]), function(paragraph) {
		      var imgCount = paragraph.getElementsByTagName("img").length;
		      var embedCount = paragraph.getElementsByTagName("embed").length;
		      var objectCount = paragraph.getElementsByTagName("object").length;
		      var iframeCount = paragraph.getElementsByTagName("iframe").length;
		      var totalCount = imgCount + embedCount + objectCount + iframeCount;
		      return totalCount === 0 && !this._getInnerText(paragraph, false);
		    });
		    this._forEachNode(this._getAllNodesWithTag(articleContent, ["br"]), function(br) {
		      var next = this._nextNode(br.nextSibling);
		      if (next && next.tagName == "P")
		        br.parentNode.removeChild(br);
		    });
		    this._forEachNode(this._getAllNodesWithTag(articleContent, ["table"]), function(table) {
		      var tbody = this._hasSingleTagInsideElement(table, "TBODY") ? table.firstElementChild : table;
		      if (this._hasSingleTagInsideElement(tbody, "TR")) {
		        var row = tbody.firstElementChild;
		        if (this._hasSingleTagInsideElement(row, "TD")) {
		          var cell = row.firstElementChild;
		          cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? "P" : "DIV");
		          table.parentNode.replaceChild(cell, table);
		        }
		      }
		    });
		  }, "_prepArticle"),
		  /**
		   * Initialize a node with the readability object. Also checks the
		   * className/id for special names to add to its score.
		   *
		   * @param Element
		   * @return void
		  **/
		  _initializeNode: /* @__PURE__ */ __name(function(node) {
		    node.readability = { "contentScore": 0 };
		    switch (node.tagName) {
		      case "DIV":
		        node.readability.contentScore += 5;
		        break;
		      case "PRE":
		      case "TD":
		      case "BLOCKQUOTE":
		        node.readability.contentScore += 3;
		        break;
		      case "ADDRESS":
		      case "OL":
		      case "UL":
		      case "DL":
		      case "DD":
		      case "DT":
		      case "LI":
		      case "FORM":
		        node.readability.contentScore -= 3;
		        break;
		      case "H1":
		      case "H2":
		      case "H3":
		      case "H4":
		      case "H5":
		      case "H6":
		      case "TH":
		        node.readability.contentScore -= 5;
		        break;
		    }
		    node.readability.contentScore += this._getClassWeight(node);
		  }, "_initializeNode"),
		  _removeAndGetNext: /* @__PURE__ */ __name(function(node) {
		    var nextNode = this._getNextNode(node, true);
		    node.parentNode.removeChild(node);
		    return nextNode;
		  }, "_removeAndGetNext"),
		  /**
		   * Traverse the DOM from node to node, starting at the node passed in.
		   * Pass true for the second parameter to indicate this node itself
		   * (and its kids) are going away, and we want the next node over.
		   *
		   * Calling this in a loop will traverse the DOM depth-first.
		   */
		  _getNextNode: /* @__PURE__ */ __name(function(node, ignoreSelfAndKids) {
		    if (!ignoreSelfAndKids && node.firstElementChild) {
		      return node.firstElementChild;
		    }
		    if (node.nextElementSibling) {
		      return node.nextElementSibling;
		    }
		    do {
		      node = node.parentNode;
		    } while (node && !node.nextElementSibling);
		    return node && node.nextElementSibling;
		  }, "_getNextNode"),
		  // compares second text to first one
		  // 1 = same text, 0 = completely different text
		  // works the way that it splits both texts into words and then finds words that are unique in second text
		  // the result is given by the lower length of unique parts
		  _textSimilarity: /* @__PURE__ */ __name(function(textA, textB) {
		    var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
		    var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);
		    if (!tokensA.length || !tokensB.length) {
		      return 0;
		    }
		    var uniqTokensB = tokensB.filter((token) => !tokensA.includes(token));
		    var distanceB = uniqTokensB.join(" ").length / tokensB.join(" ").length;
		    return 1 - distanceB;
		  }, "_textSimilarity"),
		  _checkByline: /* @__PURE__ */ __name(function(node, matchString) {
		    if (this._articleByline) {
		      return false;
		    }
		    if (node.getAttribute !== undefined) {
		      var rel = node.getAttribute("rel");
		      var itemprop = node.getAttribute("itemprop");
		    }
		    if ((rel === "author" || itemprop && itemprop.indexOf("author") !== -1 || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {
		      this._articleByline = node.textContent.trim();
		      return true;
		    }
		    return false;
		  }, "_checkByline"),
		  _getNodeAncestors: /* @__PURE__ */ __name(function(node, maxDepth) {
		    maxDepth = maxDepth || 0;
		    var i = 0, ancestors = [];
		    while (node.parentNode) {
		      ancestors.push(node.parentNode);
		      if (maxDepth && ++i === maxDepth)
		        break;
		      node = node.parentNode;
		    }
		    return ancestors;
		  }, "_getNodeAncestors"),
		  /***
		   * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
		   *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
		   *
		   * @param page a document to run upon. Needs to be a full document, complete with body.
		   * @return Element
		  **/
		  _grabArticle: /* @__PURE__ */ __name(function(page) {
		    this.log("**** grabArticle ****");
		    var doc = this._doc;
		    var isPaging = page !== null;
		    page = page ? page : this._doc.body;
		    if (!page) {
		      this.log("No body found in document. Abort.");
		      return null;
		    }
		    var pageCacheHtml = page.innerHTML;
		    while (true) {
		      this.log("Starting grabArticle loop");
		      var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);
		      var elementsToScore = [];
		      var node = this._doc.documentElement;
		      let shouldRemoveTitleHeader = true;
		      while (node) {
		        if (node.tagName === "HTML") {
		          this._articleLang = node.getAttribute("lang");
		        }
		        var matchString = node.className + " " + node.id;
		        if (!this._isProbablyVisible(node)) {
		          this.log("Removing hidden node - " + matchString);
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (node.getAttribute("aria-modal") == "true" && node.getAttribute("role") == "dialog") {
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (this._checkByline(node, matchString)) {
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {
		          this.log("Removing header: ", node.textContent.trim(), this._articleTitle.trim());
		          shouldRemoveTitleHeader = false;
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (stripUnlikelyCandidates) {
		          if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, "table") && !this._hasAncestorTag(node, "code") && node.tagName !== "BODY" && node.tagName !== "A") {
		            this.log("Removing unlikely candidate - " + matchString);
		            node = this._removeAndGetNext(node);
		            continue;
		          }
		          if (this.UNLIKELY_ROLES.includes(node.getAttribute("role"))) {
		            this.log("Removing content with role " + node.getAttribute("role") + " - " + matchString);
		            node = this._removeAndGetNext(node);
		            continue;
		          }
		        }
		        if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" || node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" || node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") && this._isElementWithoutContent(node)) {
		          node = this._removeAndGetNext(node);
		          continue;
		        }
		        if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {
		          elementsToScore.push(node);
		        }
		        if (node.tagName === "DIV") {
		          var p = null;
		          var childNode = node.firstChild;
		          while (childNode) {
		            var nextSibling = childNode.nextSibling;
		            if (this._isPhrasingContent(childNode)) {
		              if (p !== null) {
		                p.appendChild(childNode);
		              } else if (!this._isWhitespace(childNode)) {
		                p = doc.createElement("p");
		                node.replaceChild(p, childNode);
		                p.appendChild(childNode);
		              }
		            } else if (p !== null) {
		              while (p.lastChild && this._isWhitespace(p.lastChild)) {
		                p.removeChild(p.lastChild);
		              }
		              p = null;
		            }
		            childNode = nextSibling;
		          }
		          if (this._hasSingleTagInsideElement(node, "P") && this._getLinkDensity(node) < 0.25) {
		            var newNode = node.children[0];
		            node.parentNode.replaceChild(newNode, node);
		            node = newNode;
		            elementsToScore.push(node);
		          } else if (!this._hasChildBlockElement(node)) {
		            node = this._setNodeTag(node, "P");
		            elementsToScore.push(node);
		          }
		        }
		        node = this._getNextNode(node);
		      }
		      var candidates = [];
		      this._forEachNode(elementsToScore, function(elementToScore) {
		        if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === "undefined")
		          return;
		        var innerText = this._getInnerText(elementToScore);
		        if (innerText.length < 25)
		          return;
		        var ancestors2 = this._getNodeAncestors(elementToScore, 5);
		        if (ancestors2.length === 0)
		          return;
		        var contentScore = 0;
		        contentScore += 1;
		        contentScore += innerText.split(this.REGEXPS.commas).length;
		        contentScore += Math.min(Math.floor(innerText.length / 100), 3);
		        this._forEachNode(ancestors2, function(ancestor, level) {
		          if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === "undefined")
		            return;
		          if (typeof ancestor.readability === "undefined") {
		            this._initializeNode(ancestor);
		            candidates.push(ancestor);
		          }
		          if (level === 0)
		            var scoreDivider = 1;
		          else if (level === 1)
		            scoreDivider = 2;
		          else
		            scoreDivider = level * 3;
		          ancestor.readability.contentScore += contentScore / scoreDivider;
		        });
		      });
		      var topCandidates = [];
		      for (var c = 0, cl = candidates.length; c < cl; c += 1) {
		        var candidate = candidates[c];
		        var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
		        candidate.readability.contentScore = candidateScore;
		        this.log("Candidate:", candidate, "with score " + candidateScore);
		        for (var t = 0; t < this._nbTopCandidates; t++) {
		          var aTopCandidate = topCandidates[t];
		          if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
		            topCandidates.splice(t, 0, candidate);
		            if (topCandidates.length > this._nbTopCandidates)
		              topCandidates.pop();
		            break;
		          }
		        }
		      }
		      var topCandidate = topCandidates[0] || null;
		      var neededToCreateTopCandidate = false;
		      var parentOfTopCandidate;
		      if (topCandidate === null || topCandidate.tagName === "BODY") {
		        topCandidate = doc.createElement("DIV");
		        neededToCreateTopCandidate = true;
		        while (page.firstChild) {
		          this.log("Moving child out:", page.firstChild);
		          topCandidate.appendChild(page.firstChild);
		        }
		        page.appendChild(topCandidate);
		        this._initializeNode(topCandidate);
		      } else if (topCandidate) {
		        var alternativeCandidateAncestors = [];
		        for (var i = 1; i < topCandidates.length; i++) {
		          if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
		            alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));
		          }
		        }
		        var MINIMUM_TOPCANDIDATES = 3;
		        if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
		          parentOfTopCandidate = topCandidate.parentNode;
		          while (parentOfTopCandidate.tagName !== "BODY") {
		            var listsContainingThisAncestor = 0;
		            for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
		              listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));
		            }
		            if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
		              topCandidate = parentOfTopCandidate;
		              break;
		            }
		            parentOfTopCandidate = parentOfTopCandidate.parentNode;
		          }
		        }
		        if (!topCandidate.readability) {
		          this._initializeNode(topCandidate);
		        }
		        parentOfTopCandidate = topCandidate.parentNode;
		        var lastScore = topCandidate.readability.contentScore;
		        var scoreThreshold = lastScore / 3;
		        while (parentOfTopCandidate.tagName !== "BODY") {
		          if (!parentOfTopCandidate.readability) {
		            parentOfTopCandidate = parentOfTopCandidate.parentNode;
		            continue;
		          }
		          var parentScore = parentOfTopCandidate.readability.contentScore;
		          if (parentScore < scoreThreshold)
		            break;
		          if (parentScore > lastScore) {
		            topCandidate = parentOfTopCandidate;
		            break;
		          }
		          lastScore = parentOfTopCandidate.readability.contentScore;
		          parentOfTopCandidate = parentOfTopCandidate.parentNode;
		        }
		        parentOfTopCandidate = topCandidate.parentNode;
		        while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
		          topCandidate = parentOfTopCandidate;
		          parentOfTopCandidate = topCandidate.parentNode;
		        }
		        if (!topCandidate.readability) {
		          this._initializeNode(topCandidate);
		        }
		      }
		      var articleContent = doc.createElement("DIV");
		      if (isPaging)
		        articleContent.id = "readability-content";
		      var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);
		      parentOfTopCandidate = topCandidate.parentNode;
		      var siblings = parentOfTopCandidate.children;
		      for (var s = 0, sl = siblings.length; s < sl; s++) {
		        var sibling = siblings[s];
		        var append = false;
		        this.log("Looking at sibling node:", sibling, sibling.readability ? "with score " + sibling.readability.contentScore : "");
		        this.log("Sibling has score", sibling.readability ? sibling.readability.contentScore : "Unknown");
		        if (sibling === topCandidate) {
		          append = true;
		        } else {
		          var contentBonus = 0;
		          if (sibling.className === topCandidate.className && topCandidate.className !== "")
		            contentBonus += topCandidate.readability.contentScore * 0.2;
		          if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {
		            append = true;
		          } else if (sibling.nodeName === "P") {
		            var linkDensity = this._getLinkDensity(sibling);
		            var nodeContent = this._getInnerText(sibling);
		            var nodeLength = nodeContent.length;
		            if (nodeLength > 80 && linkDensity < 0.25) {
		              append = true;
		            } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\\.( |$)/) !== -1) {
		              append = true;
		            }
		          }
		        }
		        if (append) {
		          this.log("Appending node:", sibling);
		          if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {
		            this.log("Altering sibling:", sibling, "to div.");
		            sibling = this._setNodeTag(sibling, "DIV");
		          }
		          articleContent.appendChild(sibling);
		          siblings = parentOfTopCandidate.children;
		          s -= 1;
		          sl -= 1;
		        }
		      }
		      if (this._debug)
		        this.log("Article content pre-prep: " + articleContent.innerHTML);
		      this._prepArticle(articleContent);
		      if (this._debug)
		        this.log("Article content post-prep: " + articleContent.innerHTML);
		      if (neededToCreateTopCandidate) {
		        topCandidate.id = "readability-page-1";
		        topCandidate.className = "page";
		      } else {
		        var div = doc.createElement("DIV");
		        div.id = "readability-page-1";
		        div.className = "page";
		        while (articleContent.firstChild) {
		          div.appendChild(articleContent.firstChild);
		        }
		        articleContent.appendChild(div);
		      }
		      if (this._debug)
		        this.log("Article content after paging: " + articleContent.innerHTML);
		      var parseSuccessful = true;
		      var textLength = this._getInnerText(articleContent, true).length;
		      if (textLength < this._charThreshold) {
		        parseSuccessful = false;
		        page.innerHTML = pageCacheHtml;
		        if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
		          this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
		          this._attempts.push({ articleContent, textLength });
		        } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
		          this._removeFlag(this.FLAG_WEIGHT_CLASSES);
		          this._attempts.push({ articleContent, textLength });
		        } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
		          this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
		          this._attempts.push({ articleContent, textLength });
		        } else {
		          this._attempts.push({ articleContent, textLength });
		          this._attempts.sort(function(a, b) {
		            return b.textLength - a.textLength;
		          });
		          if (!this._attempts[0].textLength) {
		            return null;
		          }
		          articleContent = this._attempts[0].articleContent;
		          parseSuccessful = true;
		        }
		      }
		      if (parseSuccessful) {
		        var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));
		        this._someNode(ancestors, function(ancestor) {
		          if (!ancestor.tagName)
		            return false;
		          var articleDir = ancestor.getAttribute("dir");
		          if (articleDir) {
		            this._articleDir = articleDir;
		            return true;
		          }
		          return false;
		        });
		        return articleContent;
		      }
		    }
		  }, "_grabArticle"),
		  /**
		   * Check whether the input string could be a byline.
		   * This verifies that the input is a string, and that the length
		   * is less than 100 chars.
		   *
		   * @param possibleByline {string} - a string to check whether its a byline.
		   * @return Boolean - whether the input string is a byline.
		   */
		  _isValidByline: /* @__PURE__ */ __name(function(byline) {
		    if (typeof byline == "string" || byline instanceof String) {
		      byline = byline.trim();
		      return byline.length > 0 && byline.length < 100;
		    }
		    return false;
		  }, "_isValidByline"),
		  /**
		   * Converts some of the common HTML entities in string to their corresponding characters.
		   *
		   * @param str {string} - a string to unescape.
		   * @return string without HTML entity.
		   */
		  _unescapeHtmlEntities: /* @__PURE__ */ __name(function(str) {
		    if (!str) {
		      return str;
		    }
		    var htmlEscapeMap = this.HTML_ESCAPE_MAP;
		    return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {
		      return htmlEscapeMap[tag];
		    }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_, hex, numStr) {
		      var num = parseInt(hex || numStr, hex ? 16 : 10);
		      return String.fromCharCode(num);
		    });
		  }, "_unescapeHtmlEntities"),
		  /**
		   * Try to extract metadata from JSON-LD object.
		   * For now, only Schema.org objects of type Article or its subtypes are supported.
		   * @return Object with any metadata that could be extracted (possibly none)
		   */
		  _getJSONLD: /* @__PURE__ */ __name(function(doc) {
		    var scripts = this._getAllNodesWithTag(doc, ["script"]);
		    var metadata;
		    this._forEachNode(scripts, function(jsonLdElement) {
		      if (!metadata && jsonLdElement.getAttribute("type") === "application/ld+json") {
		        try {
		          var content = jsonLdElement.textContent.replace(/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g, "");
		          var parsed = JSON.parse(content);
		          if (!parsed["@context"] || !parsed["@context"].match(/^https?\\:\\/\\/schema\\.org$/)) {
		            return;
		          }
		          if (!parsed["@type"] && Array.isArray(parsed["@graph"])) {
		            parsed = parsed["@graph"].find(function(it) {
		              return (it["@type"] || "").match(
		                this.REGEXPS.jsonLdArticleTypes
		              );
		            });
		          }
		          if (!parsed || !parsed["@type"] || !parsed["@type"].match(this.REGEXPS.jsonLdArticleTypes)) {
		            return;
		          }
		          metadata = {};
		          if (typeof parsed.name === "string" && typeof parsed.headline === "string" && parsed.name !== parsed.headline) {
		            var title = this._getArticleTitle();
		            var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;
		            var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;
		            if (headlineMatches && !nameMatches) {
		              metadata.title = parsed.headline;
		            } else {
		              metadata.title = parsed.name;
		            }
		          } else if (typeof parsed.name === "string") {
		            metadata.title = parsed.name.trim();
		          } else if (typeof parsed.headline === "string") {
		            metadata.title = parsed.headline.trim();
		          }
		          if (parsed.author) {
		            if (typeof parsed.author.name === "string") {
		              metadata.byline = parsed.author.name.trim();
		            } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === "string") {
		              metadata.byline = parsed.author.filter(function(author) {
		                return author && typeof author.name === "string";
		              }).map(function(author) {
		                return author.name.trim();
		              }).join(", ");
		            }
		          }
		          if (typeof parsed.description === "string") {
		            metadata.excerpt = parsed.description.trim();
		          }
		          if (parsed.publisher && typeof parsed.publisher.name === "string") {
		            metadata.siteName = parsed.publisher.name.trim();
		          }
		          if (typeof parsed.datePublished === "string") {
		            metadata.datePublished = parsed.datePublished.trim();
		          }
		          return;
		        } catch (err) {
		          this.log(err.message);
		        }
		      }
		    });
		    return metadata ? metadata : {};
		  }, "_getJSONLD"),
		  /**
		   * Attempts to get excerpt and byline metadata for the article.
		   *
		   * @param {Object} jsonld — object containing any metadata that
		   * could be extracted from JSON-LD object.
		   *
		   * @return Object with optional "excerpt" and "byline" properties
		   */
		  _getArticleMetadata: /* @__PURE__ */ __name(function(jsonld) {
		    var metadata = {};
		    var values = {};
		    var metaElements = this._doc.getElementsByTagName("meta");
		    var propertyPattern = /\\s*(article|dc|dcterm|og|twitter)\\s*:\\s*(author|creator|description|published_time|title|site_name)\\s*/gi;
		    var namePattern = /^\\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\\s*[\\.:]\\s*)?(author|creator|description|title|site_name)\\s*$/i;
		    this._forEachNode(metaElements, function(element) {
		      var elementName = element.getAttribute("name");
		      var elementProperty = element.getAttribute("property");
		      var content = element.getAttribute("content");
		      if (!content) {
		        return;
		      }
		      var matches = null;
		      var name = null;
		      if (elementProperty) {
		        matches = elementProperty.match(propertyPattern);
		        if (matches) {
		          name = matches[0].toLowerCase().replace(/\\s/g, "");
		          values[name] = content.trim();
		        }
		      }
		      if (!matches && elementName && namePattern.test(elementName)) {
		        name = elementName;
		        if (content) {
		          name = name.toLowerCase().replace(/\\s/g, "").replace(/\\./g, ":");
		          values[name] = content.trim();
		        }
		      }
		    });
		    metadata.title = jsonld.title || values["dc:title"] || values["dcterm:title"] || values["og:title"] || values["weibo:article:title"] || values["weibo:webpage:title"] || values["title"] || values["twitter:title"];
		    if (!metadata.title) {
		      metadata.title = this._getArticleTitle();
		    }
		    metadata.byline = jsonld.byline || values["dc:creator"] || values["dcterm:creator"] || values["author"];
		    metadata.excerpt = jsonld.excerpt || values["dc:description"] || values["dcterm:description"] || values["og:description"] || values["weibo:article:description"] || values["weibo:webpage:description"] || values["description"] || values["twitter:description"];
		    metadata.siteName = jsonld.siteName || values["og:site_name"];
		    metadata.publishedTime = jsonld.datePublished || values["article:published_time"] || null;
		    metadata.title = this._unescapeHtmlEntities(metadata.title);
		    metadata.byline = this._unescapeHtmlEntities(metadata.byline);
		    metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);
		    metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);
		    metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);
		    return metadata;
		  }, "_getArticleMetadata"),
		  /**
		   * Check if node is image, or if node contains exactly only one image
		   * whether as a direct child or as its descendants.
		   *
		   * @param Element
		  **/
		  _isSingleImage: /* @__PURE__ */ __name(function(node) {
		    if (node.tagName === "IMG") {
		      return true;
		    }
		    if (node.children.length !== 1 || node.textContent.trim() !== "") {
		      return false;
		    }
		    return this._isSingleImage(node.children[0]);
		  }, "_isSingleImage"),
		  /**
		   * Find all <noscript> that are located after <img> nodes, and which contain only one
		   * <img> element. Replace the first image with the image from inside the <noscript> tag,
		   * and remove the <noscript> tag. This improves the quality of the images we use on
		   * some sites (e.g. Medium).
		   *
		   * @param Element
		  **/
		  _unwrapNoscriptImages: /* @__PURE__ */ __name(function(doc) {
		    var imgs = Array.from(doc.getElementsByTagName("img"));
		    this._forEachNode(imgs, function(img) {
		      for (var i = 0; i < img.attributes.length; i++) {
		        var attr = img.attributes[i];
		        switch (attr.name) {
		          case "src":
		          case "srcset":
		          case "data-src":
		          case "data-srcset":
		            return;
		        }
		        if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
		          return;
		        }
		      }
		      img.parentNode.removeChild(img);
		    });
		    var noscripts = Array.from(doc.getElementsByTagName("noscript"));
		    this._forEachNode(noscripts, function(noscript) {
		      var tmp = doc.createElement("div");
		      tmp.innerHTML = noscript.innerHTML;
		      if (!this._isSingleImage(tmp)) {
		        return;
		      }
		      var prevElement = noscript.previousElementSibling;
		      if (prevElement && this._isSingleImage(prevElement)) {
		        var prevImg = prevElement;
		        if (prevImg.tagName !== "IMG") {
		          prevImg = prevElement.getElementsByTagName("img")[0];
		        }
		        var newImg = tmp.getElementsByTagName("img")[0];
		        for (var i = 0; i < prevImg.attributes.length; i++) {
		          var attr = prevImg.attributes[i];
		          if (attr.value === "") {
		            continue;
		          }
		          if (attr.name === "src" || attr.name === "srcset" || /\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
		            if (newImg.getAttribute(attr.name) === attr.value) {
		              continue;
		            }
		            var attrName = attr.name;
		            if (newImg.hasAttribute(attrName)) {
		              attrName = "data-old-" + attrName;
		            }
		            newImg.setAttribute(attrName, attr.value);
		          }
		        }
		        noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);
		      }
		    });
		  }, "_unwrapNoscriptImages"),
		  /**
		   * Removes script tags from the document.
		   *
		   * @param Element
		  **/
		  _removeScripts: /* @__PURE__ */ __name(function(doc) {
		    this._removeNodes(this._getAllNodesWithTag(doc, ["script", "noscript"]));
		  }, "_removeScripts"),
		  /**
		   * Check if this node has only whitespace and a single element with given tag
		   * Returns false if the DIV node contains non-empty text nodes
		   * or if it contains no element with given tag or more than 1 element.
		   *
		   * @param Element
		   * @param string tag of child element
		  **/
		  _hasSingleTagInsideElement: /* @__PURE__ */ __name(function(element, tag) {
		    if (element.children.length != 1 || element.children[0].tagName !== tag) {
		      return false;
		    }
		    return !this._someNode(element.childNodes, function(node) {
		      return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);
		    });
		  }, "_hasSingleTagInsideElement"),
		  _isElementWithoutContent: /* @__PURE__ */ __name(function(node) {
		    return node.nodeType === this.ELEMENT_NODE && node.textContent.trim().length == 0 && (node.children.length == 0 || node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
		  }, "_isElementWithoutContent"),
		  /**
		   * Determine whether element has any children block level elements.
		   *
		   * @param Element
		   */
		  _hasChildBlockElement: /* @__PURE__ */ __name(function(element) {
		    return this._someNode(element.childNodes, function(node) {
		      return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);
		    });
		  }, "_hasChildBlockElement"),
		  /***
		   * Determine if a node qualifies as phrasing content.
		   * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
		  **/
		  _isPhrasingContent: /* @__PURE__ */ __name(function(node) {
		    return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 || (node.tagName === "A" || node.tagName === "DEL" || node.tagName === "INS") && this._everyNode(node.childNodes, this._isPhrasingContent);
		  }, "_isPhrasingContent"),
		  _isWhitespace: /* @__PURE__ */ __name(function(node) {
		    return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === "BR";
		  }, "_isWhitespace"),
		  /**
		   * Get the inner text of a node - cross browser compatibly.
		   * This also strips out any excess whitespace to be found.
		   *
		   * @param Element
		   * @param Boolean normalizeSpaces (default: true)
		   * @return string
		  **/
		  _getInnerText: /* @__PURE__ */ __name(function(e, normalizeSpaces) {
		    normalizeSpaces = typeof normalizeSpaces === "undefined" ? true : normalizeSpaces;
		    var textContent = e.textContent.trim();
		    if (normalizeSpaces) {
		      return textContent.replace(this.REGEXPS.normalize, " ");
		    }
		    return textContent;
		  }, "_getInnerText"),
		  /**
		   * Get the number of times a string s appears in the node e.
		   *
		   * @param Element
		   * @param string - what to split on. Default is ","
		   * @return number (integer)
		  **/
		  _getCharCount: /* @__PURE__ */ __name(function(e, s) {
		    s = s || ",";
		    return this._getInnerText(e).split(s).length - 1;
		  }, "_getCharCount"),
		  /**
		   * Remove the style attribute on every e and under.
		   * TODO: Test if getElementsByTagName(*) is faster.
		   *
		   * @param Element
		   * @return void
		  **/
		  _cleanStyles: /* @__PURE__ */ __name(function(e) {
		    if (!e || e.tagName.toLowerCase() === "svg")
		      return;
		    for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {
		      e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);
		    }
		    if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {
		      e.removeAttribute("width");
		      e.removeAttribute("height");
		    }
		    var cur = e.firstElementChild;
		    while (cur !== null) {
		      this._cleanStyles(cur);
		      cur = cur.nextElementSibling;
		    }
		  }, "_cleanStyles"),
		  /**
		   * Get the density of links as a percentage of the content
		   * This is the amount of text that is inside a link divided by the total text in the node.
		   *
		   * @param Element
		   * @return number (float)
		  **/
		  _getLinkDensity: /* @__PURE__ */ __name(function(element) {
		    var textLength = this._getInnerText(element).length;
		    if (textLength === 0)
		      return 0;
		    var linkLength = 0;
		    this._forEachNode(element.getElementsByTagName("a"), function(linkNode) {
		      var href = linkNode.getAttribute("href");
		      var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;
		      linkLength += this._getInnerText(linkNode).length * coefficient;
		    });
		    return linkLength / textLength;
		  }, "_getLinkDensity"),
		  /**
		   * Get an elements class/id weight. Uses regular expressions to tell if this
		   * element looks good or bad.
		   *
		   * @param Element
		   * @return number (Integer)
		  **/
		  _getClassWeight: /* @__PURE__ */ __name(function(e) {
		    if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))
		      return 0;
		    var weight = 0;
		    if (typeof e.className === "string" && e.className !== "") {
		      if (this.REGEXPS.negative.test(e.className))
		        weight -= 25;
		      if (this.REGEXPS.positive.test(e.className))
		        weight += 25;
		    }
		    if (typeof e.id === "string" && e.id !== "") {
		      if (this.REGEXPS.negative.test(e.id))
		        weight -= 25;
		      if (this.REGEXPS.positive.test(e.id))
		        weight += 25;
		    }
		    return weight;
		  }, "_getClassWeight"),
		  /**
		   * Clean a node of all elements of type "tag".
		   * (Unless it's a youtube/vimeo video. People love movies.)
		   *
		   * @param Element
		   * @param string tag to clean
		   * @return void
		   **/
		  _clean: /* @__PURE__ */ __name(function(e, tag) {
		    var isEmbed = ["object", "embed", "iframe"].indexOf(tag) !== -1;
		    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element) {
		      if (isEmbed) {
		        for (var i = 0; i < element.attributes.length; i++) {
		          if (this._allowedVideoRegex.test(element.attributes[i].value)) {
		            return false;
		          }
		        }
		        if (element.tagName === "object" && this._allowedVideoRegex.test(element.innerHTML)) {
		          return false;
		        }
		      }
		      return true;
		    });
		  }, "_clean"),
		  /**
		   * Check if a given node has one of its ancestor tag name matching the
		   * provided one.
		   * @param  HTMLElement node
		   * @param  String      tagName
		   * @param  Number      maxDepth
		   * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
		   * @return Boolean
		   */
		  _hasAncestorTag: /* @__PURE__ */ __name(function(node, tagName, maxDepth, filterFn) {
		    maxDepth = maxDepth || 3;
		    tagName = tagName.toUpperCase();
		    var depth = 0;
		    while (node.parentNode) {
		      if (maxDepth > 0 && depth > maxDepth)
		        return false;
		      if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))
		        return true;
		      node = node.parentNode;
		      depth++;
		    }
		    return false;
		  }, "_hasAncestorTag"),
		  /**
		   * Return an object indicating how many rows and columns this table has.
		   */
		  _getRowAndColumnCount: /* @__PURE__ */ __name(function(table) {
		    var rows = 0;
		    var columns = 0;
		    var trs = table.getElementsByTagName("tr");
		    for (var i = 0; i < trs.length; i++) {
		      var rowspan = trs[i].getAttribute("rowspan") || 0;
		      if (rowspan) {
		        rowspan = parseInt(rowspan, 10);
		      }
		      rows += rowspan || 1;
		      var columnsInThisRow = 0;
		      var cells = trs[i].getElementsByTagName("td");
		      for (var j = 0; j < cells.length; j++) {
		        var colspan = cells[j].getAttribute("colspan") || 0;
		        if (colspan) {
		          colspan = parseInt(colspan, 10);
		        }
		        columnsInThisRow += colspan || 1;
		      }
		      columns = Math.max(columns, columnsInThisRow);
		    }
		    return { rows, columns };
		  }, "_getRowAndColumnCount"),
		  /**
		   * Look for 'data' (as opposed to 'layout') tables, for which we use
		   * similar checks as
		   * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19
		   */
		  _markDataTables: /* @__PURE__ */ __name(function(root) {
		    var tables = root.getElementsByTagName("table");
		    for (var i = 0; i < tables.length; i++) {
		      var table = tables[i];
		      var role = table.getAttribute("role");
		      if (role == "presentation") {
		        table._readabilityDataTable = false;
		        continue;
		      }
		      var datatable = table.getAttribute("datatable");
		      if (datatable == "0") {
		        table._readabilityDataTable = false;
		        continue;
		      }
		      var summary = table.getAttribute("summary");
		      if (summary) {
		        table._readabilityDataTable = true;
		        continue;
		      }
		      var caption = table.getElementsByTagName("caption")[0];
		      if (caption && caption.childNodes.length > 0) {
		        table._readabilityDataTable = true;
		        continue;
		      }
		      var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
		      var descendantExists = /* @__PURE__ */ __name(function(tag) {
		        return !!table.getElementsByTagName(tag)[0];
		      }, "descendantExists");
		      if (dataTableDescendants.some(descendantExists)) {
		        this.log("Data table because found data-y descendant");
		        table._readabilityDataTable = true;
		        continue;
		      }
		      if (table.getElementsByTagName("table")[0]) {
		        table._readabilityDataTable = false;
		        continue;
		      }
		      var sizeInfo = this._getRowAndColumnCount(table);
		      if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
		        table._readabilityDataTable = true;
		        continue;
		      }
		      table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
		    }
		  }, "_markDataTables"),
		  /* convert images and figures that have properties like data-src into images that can be loaded without JS */
		  _fixLazyImages: /* @__PURE__ */ __name(function(root) {
		    this._forEachNode(this._getAllNodesWithTag(root, ["img", "picture", "figure"]), function(elem) {
		      if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {
		        var parts = this.REGEXPS.b64DataUrl.exec(elem.src);
		        if (parts[1] === "image/svg+xml") {
		          return;
		        }
		        var srcCouldBeRemoved = false;
		        for (var i = 0; i < elem.attributes.length; i++) {
		          var attr = elem.attributes[i];
		          if (attr.name === "src") {
		            continue;
		          }
		          if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {
		            srcCouldBeRemoved = true;
		            break;
		          }
		        }
		        if (srcCouldBeRemoved) {
		          var b64starts = elem.src.search(/base64\\s*/i) + 7;
		          var b64length = elem.src.length - b64starts;
		          if (b64length < 133) {
		            elem.removeAttribute("src");
		          }
		        }
		      }
		      if ((elem.src || elem.srcset && elem.srcset != "null") && elem.className.toLowerCase().indexOf("lazy") === -1) {
		        return;
		      }
		      for (var j = 0; j < elem.attributes.length; j++) {
		        attr = elem.attributes[j];
		        if (attr.name === "src" || attr.name === "srcset" || attr.name === "alt") {
		          continue;
		        }
		        var copyTo = null;
		        if (/\\.(jpg|jpeg|png|webp)\\s+\\d/.test(attr.value)) {
		          copyTo = "srcset";
		        } else if (/^\\s*\\S+\\.(jpg|jpeg|png|webp)\\S*\\s*$/.test(attr.value)) {
		          copyTo = "src";
		        }
		        if (copyTo) {
		          if (elem.tagName === "IMG" || elem.tagName === "PICTURE") {
		            elem.setAttribute(copyTo, attr.value);
		          } else if (elem.tagName === "FIGURE" && !this._getAllNodesWithTag(elem, ["img", "picture"]).length) {
		            var img = this._doc.createElement("img");
		            img.setAttribute(copyTo, attr.value);
		            elem.appendChild(img);
		          }
		        }
		      }
		    });
		  }, "_fixLazyImages"),
		  _getTextDensity: /* @__PURE__ */ __name(function(e, tags) {
		    var textLength = this._getInnerText(e, true).length;
		    if (textLength === 0) {
		      return 0;
		    }
		    var childrenLength = 0;
		    var children = this._getAllNodesWithTag(e, tags);
		    this._forEachNode(children, (child) => childrenLength += this._getInnerText(child, true).length);
		    return childrenLength / textLength;
		  }, "_getTextDensity"),
		  /**
		   * Clean an element of all tags of type "tag" if they look fishy.
		   * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
		   *
		   * @return void
		   **/
		  _cleanConditionally: /* @__PURE__ */ __name(function(e, tag) {
		    if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))
		      return;
		    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {
		      var isDataTable = /* @__PURE__ */ __name(function(t) {
		        return t._readabilityDataTable;
		      }, "isDataTable");
		      var isList = tag === "ul" || tag === "ol";
		      if (!isList) {
		        var listLength = 0;
		        var listNodes = this._getAllNodesWithTag(node, ["ul", "ol"]);
		        this._forEachNode(listNodes, (list) => listLength += this._getInnerText(list).length);
		        isList = listLength / this._getInnerText(node).length > 0.9;
		      }
		      if (tag === "table" && isDataTable(node)) {
		        return false;
		      }
		      if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
		        return false;
		      }
		      if (this._hasAncestorTag(node, "code")) {
		        return false;
		      }
		      var weight = this._getClassWeight(node);
		      this.log("Cleaning Conditionally", node);
		      var contentScore = 0;
		      if (weight + contentScore < 0) {
		        return true;
		      }
		      if (this._getCharCount(node, ",") < 10) {
		        var p = node.getElementsByTagName("p").length;
		        var img = node.getElementsByTagName("img").length;
		        var li = node.getElementsByTagName("li").length - 100;
		        var input = node.getElementsByTagName("input").length;
		        var headingDensity = this._getTextDensity(node, ["h1", "h2", "h3", "h4", "h5", "h6"]);
		        var embedCount = 0;
		        var embeds = this._getAllNodesWithTag(node, ["object", "embed", "iframe"]);
		        for (var i = 0; i < embeds.length; i++) {
		          for (var j = 0; j < embeds[i].attributes.length; j++) {
		            if (this._allowedVideoRegex.test(embeds[i].attributes[j].value)) {
		              return false;
		            }
		          }
		          if (embeds[i].tagName === "object" && this._allowedVideoRegex.test(embeds[i].innerHTML)) {
		            return false;
		          }
		          embedCount++;
		        }
		        var linkDensity = this._getLinkDensity(node);
		        var contentLength = this._getInnerText(node).length;
		        var haveToRemove = img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, "figure") || !isList && li > p || input > Math.floor(p / 3) || !isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, "figure") || !isList && weight < 25 && linkDensity > 0.2 || weight >= 25 && linkDensity > 0.5 || (embedCount === 1 && contentLength < 75 || embedCount > 1);
		        if (isList && haveToRemove) {
		          for (var x = 0; x < node.children.length; x++) {
		            let child = node.children[x];
		            if (child.children.length > 1) {
		              return haveToRemove;
		            }
		          }
		          let li_count = node.getElementsByTagName("li").length;
		          if (img == li_count) {
		            return false;
		          }
		        }
		        return haveToRemove;
		      }
		      return false;
		    });
		  }, "_cleanConditionally"),
		  /**
		   * Clean out elements that match the specified conditions
		   *
		   * @param Element
		   * @param Function determines whether a node should be removed
		   * @return void
		   **/
		  _cleanMatchedNodes: /* @__PURE__ */ __name(function(e, filter) {
		    var endOfSearchMarkerNode = this._getNextNode(e, true);
		    var next = this._getNextNode(e);
		    while (next && next != endOfSearchMarkerNode) {
		      if (filter.call(this, next, next.className + " " + next.id)) {
		        next = this._removeAndGetNext(next);
		      } else {
		        next = this._getNextNode(next);
		      }
		    }
		  }, "_cleanMatchedNodes"),
		  /**
		   * Clean out spurious headers from an Element.
		   *
		   * @param Element
		   * @return void
		  **/
		  _cleanHeaders: /* @__PURE__ */ __name(function(e) {
		    let headingNodes = this._getAllNodesWithTag(e, ["h1", "h2"]);
		    this._removeNodes(headingNodes, function(node) {
		      let shouldRemove = this._getClassWeight(node) < 0;
		      if (shouldRemove) {
		        this.log("Removing header with low class weight:", node);
		      }
		      return shouldRemove;
		    });
		  }, "_cleanHeaders"),
		  /**
		   * Check if this node is an H1 or H2 element whose content is mostly
		   * the same as the article title.
		   *
		   * @param Element  the node to check.
		   * @return boolean indicating whether this is a title-like header.
		   */
		  _headerDuplicatesTitle: /* @__PURE__ */ __name(function(node) {
		    if (node.tagName != "H1" && node.tagName != "H2") {
		      return false;
		    }
		    var heading = this._getInnerText(node, false);
		    this.log("Evaluating similarity of header:", heading, this._articleTitle);
		    return this._textSimilarity(this._articleTitle, heading) > 0.75;
		  }, "_headerDuplicatesTitle"),
		  _flagIsActive: /* @__PURE__ */ __name(function(flag) {
		    return (this._flags & flag) > 0;
		  }, "_flagIsActive"),
		  _removeFlag: /* @__PURE__ */ __name(function(flag) {
		    this._flags = this._flags & ~flag;
		  }, "_removeFlag"),
		  _isProbablyVisible: /* @__PURE__ */ __name(function(node) {
		    return (!node.style || node.style.display != "none") && (!node.style || node.style.visibility != "hidden") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
		  }, "_isProbablyVisible"),
		  /**
		   * Runs readability.
		   *
		   * Workflow:
		   *  1. Prep the document by removing script tags, css, etc.
		   *  2. Build readability's DOM tree.
		   *  3. Grab the article content from the current dom tree.
		   *  4. Replace the current DOM tree with the new one.
		   *  5. Read peacefully.
		   *
		   * @return void
		   **/
		  parse: /* @__PURE__ */ __name(function() {
		    if (this._maxElemsToParse > 0) {
		      var numTags = this._doc.getElementsByTagName("*").length;
		      if (numTags > this._maxElemsToParse) {
		        throw new Error("Aborting parsing document; " + numTags + " elements found");
		      }
		    }
		    this._unwrapNoscriptImages(this._doc);
		    var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);
		    this._removeScripts(this._doc);
		    this._prepDocument();
		    var metadata = this._getArticleMetadata(jsonLd);
		    this._articleTitle = metadata.title;
		    var articleContent = this._grabArticle();
		    if (!articleContent)
		      return null;
		    this.log("Grabbed: " + articleContent.innerHTML);
		    this._postProcessContent(articleContent);
		    if (!metadata.excerpt) {
		      var paragraphs = articleContent.getElementsByTagName("p");
		      if (paragraphs.length > 0) {
		        metadata.excerpt = paragraphs[0].textContent.trim();
		      }
		    }
		    var textContent = articleContent.textContent;
		    return {
		      title: this._articleTitle,
		      byline: metadata.byline || this._articleByline,
		      dir: this._articleDir,
		      lang: this._articleLang,
		      content: this._serializer(articleContent),
		      textContent,
		      length: textContent.length,
		      excerpt: metadata.excerpt,
		      siteName: metadata.siteName || this._articleSiteName,
		      publishedTime: metadata.publishedTime
		    };
		  }, "parse")
		};
		{
		  module.exports = Readability;
		} 
	} (Readability));
	return Readability.exports;
}

var ReadabilityReaderable = {exports: {}};

var hasRequiredReadabilityReaderable;

function requireReadabilityReaderable () {
	if (hasRequiredReadabilityReaderable) return ReadabilityReaderable.exports;
	hasRequiredReadabilityReaderable = 1;
	(function (module) {
		var __defProp = Object.defineProperty;
		var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
		var REGEXPS = {
		  // NOTE: These two regular expressions are duplicated in
		  // Readability.js. Please keep both copies in sync.
		  unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,
		  okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i
		};
		function isNodeVisible(node) {
		  return (!node.style || node.style.display != "none") && !node.hasAttribute("hidden") && (!node.hasAttribute("aria-hidden") || node.getAttribute("aria-hidden") != "true" || node.className && node.className.indexOf && node.className.indexOf("fallback-image") !== -1);
		}
		__name(isNodeVisible, "isNodeVisible");
		function isProbablyReaderable(doc, options = {}) {
		  if (typeof options == "function") {
		    options = { visibilityChecker: options };
		  }
		  var defaultOptions = { minScore: 20, minContentLength: 140, visibilityChecker: isNodeVisible };
		  options = Object.assign(defaultOptions, options);
		  var nodes = doc.querySelectorAll("p, pre, article");
		  var brNodes = doc.querySelectorAll("div > br");
		  if (brNodes.length) {
		    var set = new Set(nodes);
		    [].forEach.call(brNodes, function(node) {
		      set.add(node.parentNode);
		    });
		    nodes = Array.from(set);
		  }
		  var score = 0;
		  return [].some.call(nodes, function(node) {
		    if (!options.visibilityChecker(node)) {
		      return false;
		    }
		    var matchString = node.className + " " + node.id;
		    if (REGEXPS.unlikelyCandidates.test(matchString) && !REGEXPS.okMaybeItsACandidate.test(matchString)) {
		      return false;
		    }
		    if (node.matches("li p")) {
		      return false;
		    }
		    var textContentLength = node.textContent.trim().length;
		    if (textContentLength < options.minContentLength) {
		      return false;
		    }
		    score += Math.sqrt(textContentLength - options.minContentLength);
		    if (score > options.minScore) {
		      return true;
		    }
		    return false;
		  });
		}
		__name(isProbablyReaderable, "isProbablyReaderable");
		{
		  module.exports = isProbablyReaderable;
		} 
	} (ReadabilityReaderable));
	return ReadabilityReaderable.exports;
}

var readability;
var hasRequiredReadability;

function requireReadability () {
	if (hasRequiredReadability) return readability;
	hasRequiredReadability = 1;
	var Readability = requireReadability$1();
	var isProbablyReaderable = requireReadabilityReaderable();
	readability = {
	  Readability,
	  isProbablyReaderable
	};
	return readability;
}

var readabilityExports = requireReadability();

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	var __defProp = Object.defineProperty;
	var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
	let p = process || {};
	let argv = p.argv || [];
	let env = p.env || {};
	let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
	let formatter = /* @__PURE__ */ __name((open, close, replace = open) => (input) => {
	  let string = "" + input, index = string.indexOf(close, open.length);
	  return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	}, "formatter");
	let replaceClose = /* @__PURE__ */ __name((string, close, replace, index) => {
	  let result = "", cursor = 0;
	  do {
	    result += string.substring(cursor, index) + replace;
	    cursor = index + close.length;
	    index = string.indexOf(close, cursor);
	  } while (~index);
	  return result + string.substring(cursor);
	}, "replaceClose");
	let createColors = /* @__PURE__ */ __name((enabled = isColorSupported) => {
	  let f = enabled ? formatter : () => String;
	  return {
	    isColorSupported: enabled,
	    reset: f("\\x1B[0m", "\\x1B[0m"),
	    bold: f("\\x1B[1m", "\\x1B[22m", "\\x1B[22m\\x1B[1m"),
	    dim: f("\\x1B[2m", "\\x1B[22m", "\\x1B[22m\\x1B[2m"),
	    italic: f("\\x1B[3m", "\\x1B[23m"),
	    underline: f("\\x1B[4m", "\\x1B[24m"),
	    inverse: f("\\x1B[7m", "\\x1B[27m"),
	    hidden: f("\\x1B[8m", "\\x1B[28m"),
	    strikethrough: f("\\x1B[9m", "\\x1B[29m"),
	    black: f("\\x1B[30m", "\\x1B[39m"),
	    red: f("\\x1B[31m", "\\x1B[39m"),
	    green: f("\\x1B[32m", "\\x1B[39m"),
	    yellow: f("\\x1B[33m", "\\x1B[39m"),
	    blue: f("\\x1B[34m", "\\x1B[39m"),
	    magenta: f("\\x1B[35m", "\\x1B[39m"),
	    cyan: f("\\x1B[36m", "\\x1B[39m"),
	    white: f("\\x1B[37m", "\\x1B[39m"),
	    gray: f("\\x1B[90m", "\\x1B[39m"),
	    bgBlack: f("\\x1B[40m", "\\x1B[49m"),
	    bgRed: f("\\x1B[41m", "\\x1B[49m"),
	    bgGreen: f("\\x1B[42m", "\\x1B[49m"),
	    bgYellow: f("\\x1B[43m", "\\x1B[49m"),
	    bgBlue: f("\\x1B[44m", "\\x1B[49m"),
	    bgMagenta: f("\\x1B[45m", "\\x1B[49m"),
	    bgCyan: f("\\x1B[46m", "\\x1B[49m"),
	    bgWhite: f("\\x1B[47m", "\\x1B[49m"),
	    blackBright: f("\\x1B[90m", "\\x1B[39m"),
	    redBright: f("\\x1B[91m", "\\x1B[39m"),
	    greenBright: f("\\x1B[92m", "\\x1B[39m"),
	    yellowBright: f("\\x1B[93m", "\\x1B[39m"),
	    blueBright: f("\\x1B[94m", "\\x1B[39m"),
	    magentaBright: f("\\x1B[95m", "\\x1B[39m"),
	    cyanBright: f("\\x1B[96m", "\\x1B[39m"),
	    whiteBright: f("\\x1B[97m", "\\x1B[39m"),
	    bgBlackBright: f("\\x1B[100m", "\\x1B[49m"),
	    bgRedBright: f("\\x1B[101m", "\\x1B[49m"),
	    bgGreenBright: f("\\x1B[102m", "\\x1B[49m"),
	    bgYellowBright: f("\\x1B[103m", "\\x1B[49m"),
	    bgBlueBright: f("\\x1B[104m", "\\x1B[49m"),
	    bgMagentaBright: f("\\x1B[105m", "\\x1B[49m"),
	    bgCyanBright: f("\\x1B[106m", "\\x1B[49m"),
	    bgWhiteBright: f("\\x1B[107m", "\\x1B[49m")
	  };
	}, "createColors");
	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var picocolorsExports = /*@__PURE__*/ requirePicocolors();
const c = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

var __defProp$3 = Object.defineProperty;
var __name$3 = (target, value) => __defProp$3(target, "name", { value, configurable: true });
const turndown = new Turndown();
turndown.use(gfm);
function toMarkdown(html) {
  return turndown.turndown(html);
}
__name$3(toMarkdown, "toMarkdown");

var __defProp$2 = Object.defineProperty;
var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
class Logger {
  static {
    __name$2(this, "Logger");
  }
  level;
  setLevel(level) {
    this.level = level;
  }
  info(...args) {
    if (this.level === "silent") return;
    console.log(c.cyan("INFO"), ...args);
  }
  warn(...args) {
    if (this.level === "silent") return;
    console.warn(c.yellow("WARN"), ...args);
  }
}
const logger = new Logger();

var __defProp$1 = Object.defineProperty;
var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
function formatNumber(num) {
  return num > 1e6 ? \`\${(num / 1e6).toFixed(1)}M\` : num > 1e3 ? \`\${(num / 1e3).toFixed(1)}K\` : num.toString();
}
__name$1(formatNumber, "formatNumber");
function matchPath(path, pattern) {
  return micromatch.isMatch(path, pattern);
}
__name$1(matchPath, "matchPath");
function ensureArray(input) {
  return Array.isArray(input) ? input : [input];
}
__name$1(ensureArray, "ensureArray");

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
async function fetchSite(url, options) {
  const fetcher = new Fetcher(options);
  return fetcher.fetchSite(url);
}
__name(fetchSite, "fetchSite");
class Fetcher {
  constructor(options) {
    this.options = options;
    const concurrency = options.concurrency || 3;
    this.#queue = new PQueue({ concurrency });
  }
  static {
    __name(this, "Fetcher");
  }
  #pages = /* @__PURE__ */ new Map();
  #fetched = /* @__PURE__ */ new Set();
  #queue;
  #limitReached() {
    return this.options.limit && this.#pages.size >= this.options.limit;
  }
  #getContentSelector(pathname) {
    if (typeof this.options.contentSelector === "function")
      return this.options.contentSelector({ pathname });
    return this.options.contentSelector;
  }
  async fetchSite(url) {
    logger.info(
      \`Started fetching \${c.green(url)} with a concurrency of \${this.#queue.concurrency}\`
    );
    await this.#fetchPage(url, {
      skipMatch: true
    });
    await this.#queue.onIdle();
    return this.#pages;
  }
  async #fetchPage(url, options) {
    const { host, pathname } = new URL(url);
    if (this.#fetched.has(pathname) || this.#limitReached()) {
      return;
    }
    this.#fetched.add(pathname);
    if (!options.skipMatch && this.options.match && !matchPath(pathname, this.options.match)) {
      return;
    }
    logger.info(\`Fetching \${c.green(url)}\`);
    const res = await (this.options.fetch || fetch)(url, {
      headers: {
        "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
      }
    });
    if (!res.ok) {
      logger.warn(\`Failed to fetch \${url}: \${res.statusText}\`);
      return;
    }
    if (this.#limitReached()) {
      return;
    }
    const contentType = res.headers.get("content-type");
    if (!contentType?.includes("text/html")) {
      logger.warn(\`Not a HTML page: \${url}\`);
      return;
    }
    const resUrl = new URL(res.url);
    if (resUrl.host !== host) {
      logger.warn(\`Redirected from \${host} to \${resUrl.host}\`);
      return;
    }
    const extraUrls = [];
    const $ = load(await res.text());
    $("script,style,link,img,video").remove();
    $("a").each((_, el) => {
      const href = $(el).attr("href");
      if (!href) {
        return;
      }
      const thisUrl = new URL(href, url);
      if (thisUrl.host !== host) {
        return;
      }
      extraUrls.push(thisUrl.href);
    });
    if (extraUrls.length > 0) {
      for (const url2 of extraUrls) {
        this.#queue.add(
          () => this.#fetchPage(url2, { ...options, skipMatch: false })
        );
      }
    }
    const window = new Window({
      url,
      settings: {
        disableJavaScriptFileLoading: true,
        disableJavaScriptEvaluation: true,
        disableCSSFileLoading: true
      }
    });
    const pageTitle = $("title").text();
    const contentSelector = this.#getContentSelector(pathname);
    const html = contentSelector ? $(contentSelector).prop("outerHTML") : $.html();
    if (!html) {
      logger.warn(\`No readable content on \${pathname}\`);
      return;
    }
    window.document.write(html);
    await window.happyDOM.waitUntilComplete();
    const article = new readabilityExports.Readability(window.document).parse();
    await window.happyDOM.close();
    if (!article) {
      return;
    }
    const content = toMarkdown(article.content);
    this.#pages.set(pathname, {
      title: article.title || pageTitle,
      url,
      content
    });
  }
}
function serializePages(pages, format) {
  if (format === "json") {
    return JSON.stringify([...pages.values()]);
  }
  return [...pages.values()].map(
    (page) => \`<page>
  <title>\${page.title}</title>
  <url>\${page.url}</url>
  <content>\${page.content}</content>
</page>\`.trim()
  ).join("\\n\\n");
}
__name(serializePages, "serializePages");

export { formatNumber as a, ensureArray as e, fetchSite as f, logger as l, serializePages as s };
",
]
`;
